buffer for glyphs - number, size etc

buffer for text - arbitrary size like max RAM
- Planes use UV->texel
- Not all text is necessarily visible in the viewport at once
- Pango would render directly into this buffer

Separate update thread:
- Run pango to generate text pixels
- Apply msdf to pixels
- Write to mapped bufffer pointer

As user types or when text is loaded, it is automatically segmented into
tiles/buckets/bins etc

This results in planes of different dimensions so need to add scale per
instance

TOO MUCH MEM! - Dependent upon number of unique segments which does not
necessarily equal words

Optimizations for specific cases (by most commonly used words):
* Programming - keywords, symbols, variables etc - easy
* Prose - difficult

--------

For images, load entire image as a texture and then break into tiles
as user works on it, 2,4,8,16,32,64 etc

Make this a smart process - release tile if user moves to another tile
after a certain amount of time or learn users behavior to calculate the
threshold

]-----------------------------------------------------------------------

text   -> raster (texture) 
raster -> text (OCR)

text     -> waveform (text-to-speech)
waveform -> text (voice recognition)

raster   -> waveform (texture)
waveform -> raster (texture)

waveform/spectrogram/bitmap

Transform model different from transform view!
Both can be done at the same time!
at the same time!

At the top it's all pixels, and at the bottom it's all ones and zeros.
Only the middle needs distinguishing.

Transform abstract model like numbers to strings or vice versa
C data types or LISP data types

People think in terms of domain-specific concepts.
People can understand mathematical functions.

UNREAL BLUEPRINTS
- Cannot create new nodes with nodes - but we can!

https://news.ycombinator.com/item?id=14482988

------------------------------------------------------------------------

EMACS Model:

Bytes -> Txt -> Pango/Cairo -> DE (Wayland/OpenGL)

* Cairo 2D vector graphics
* Cairo does not use OpenGL for drawing; rather software rasterizing
* However, it can output to an OpenGL-based surface
* Cairo is a 2D drawing API and OpenGL is a 3D drawing API
* OpenGL backend exists (cairo-gl) for drawing but limited functionality


Protoform Model:

Bytes -> Txt  -> Pango/Cairo -> Protoform/OpenGL

Bytes -> Txt* -> Pango/Cairo -> OpenGL Buffer Object (RGBA) | *(char encoding, e.g. UTF-8)
Bytes -> SVG  -> Pango/Cairo -> OpenGL Buffer Object (RGBA)
Bytes -> RGBA ->     ...     -> OpenGL Buffer Object (RGBA)

DE -> RGBA...

Critique:

* Pango/Cairo can be viewed as a data transformer: bytes -> Pixels (RGBA)
* For raster, pixels are straight-forward, however SVG needs conversion
* Txt -> SVG is ostensibly an image transformer, but bytes underneath
* Transformer is moving between two domains: model -> view
* Transformer needs both INTERop and INTRAop functionality
* Technically, same function jand input, but different output

Bytes -> Txt  -> Pango/Cairo -> Protoform/OpenGL
          |
Bytes -> RGBA  -> Pango/Cairo -> Protoform/OpenGL

Txt -> Pango/Cairo -> RGBA
RGBA -> Tesseract (OCR) -> Txt

* EMACS limits domain to text being viewed solely through GTK textarea
* The frame/window concept is tied to textarea
* What we want to do, is use that same consistency and extensability
across multiple domains and to provide those features through allowing
data transformers.
* The way Protoform draws, creates two "buffers": the model or data 
structure, and the view buffer or OpenGL buffer which ultimately is 
RGBA.
* OpenGL has multiple types of buffers which are initially formatted to
a specific type:
* glMapBuffer:
  * GL_ARRAY_BUFFER, GL_ATOMIC_COUNTER_BUFFER, GL_COPY_READ_BUFFER, 
  GL_COPY_WRITE_BUFFER, GL_DRAW_INDIRECT_BUFFER, 
  GL_DISPATCH_INDIRECT_BUFFER, GL_ELEMENT_ARRAY_BUFFER, 
  GL_PIXEL_PACK_BUFFER, GL_PIXEL_UNPACK_BUFFER, GL_QUERY_BUFFER, 
  GL_SHADER_STORAGE_BUFFER, GL_TEXTURE_BUFFER, 
  GL_TRANSFORM_FEEDBACK_BUFFER, or GL_UNIFORM_BUFFER.
* Framebuffers are different: they are used for rendering output rather
than inputs and use specialized methods for operations.
* In Emacs, these OpenGL/output buffers cannot be accessed since they
exist within the memory of the DE process, so Protoform provides this
functionality to enable displaying more than just text.
* Emacs functionality is based around manipulation of the buffer model
but not the view (GTK widget), which can be considered a limitation or 
advantage.
* Does the view require data transformers?? In other words, they need to
be dynamic objects that can be modified from the view. So nodes need to
be able to edit themselves using nodes.
* For example, there exists a node. Another node with code can be 
attached to it and eval'd. Say, attach a delete transformer, which
deletes the node from memory.
* The default startup should have no nodes except for two nodes:
the OpenGL context, and attached to that node, the default framebuffer.
* A process can have multiple contexts, which represents a viewable
surface. Current context is thread-local so possibly  one context/thread

------------------------------------------------------------------------

rendering engine

Forward... -> Tiled -> Clustered -> Volumetric

 Volume Tiled Forward Shading is based on Tiled and Clustered Forward Shading described by Ola Olsson et. al
 
------------------------------------------------------------------------

;; (area   (width height) (* width height))
;;         (width  (border)       (+ 7 (* 2 border)))
;;         (height (border)       (+ 5 (* 2 border)))
;;         (border ()             1))

#|

(defun calc-area (width height)
  (:rw (:r width height)
       (:w area))
  ;; format to t
  (* width height))

(defun calc-width (border)
  (:rw (:r border)
       (:w width))
  ;; format to t
  (* 2 border))

(defun calc-height (border)
  (:rw (:r border)
       (:w height))
  ;; format to t
  (* 2 border))  

(defun calc-border ()
  (:rw (:r nil)
       (:w border))
  ;; format to t
  (setf border 1))

|#

;; sym = (or (r) (r w) (w))
;; There is no easy way of implicitly analyzing code to figure out if a symbol is going to be modified
;; - naive solution is check for *set* functions
;; - expand macros...should do this at compile time to generate main
;; Current method is to explicitly define it as the user understands it
;; a DSL would be needed for all the specifics...

;; for each symbol store read and write functions for each

;; EXAMPLE
;; For the above, can a program figure out the execution order without the user declaring it?

;; Sort defuns into hashtable where sym -> :r f0 f1 f2..., :w f0 f1 f2

;; Pass program a function, root node, to figure out dependencies
;; For read symbols, find writer fns
;; Then for each writer fn, check its read syms and find its writer fns
;; As program progresses, save fns in list/graph
;; At the end, iterate and submit tasks
;; l = (:s calc-border (:p calc-width calc-height) calc-area)

;; Ideally, there should only be one writer
;; When multiple writers - no way of knowing which should go first
;; - slap a lock on it, execute functions -> indeterministic execution

;; Iterate over predecessors:
;; Parallelizable if reads of func a do not include any writes of func b or vice versa
;; otherwise they are dependent
;; In other words, reads are arbitrary, but not the same writes

;; It's also assumed the symbols above are global

#|
(defun calc-b (a)
  (:rw (:r a)
       (:w b))

  (+ 2 a))

(defun calc-a ()
  (:rw (:r nil)
       (:w a))

  (+ 1 0))

(defun calc-a2 ()
  (:rw (:r nil)
       (:w a))

  (- 3 0))
|#

#|
1. Build hash table with functions and rw

(:s (:p #'set-inst-max
	#'set-projview
	#'set-handles-shm)
    (:p t
	t
	t)
    t)
|#

;; Static analysis of Lisp code to determine a call dependency graph
;; 

;; How to determine execution order?
;; - All functions have state
;; - Associated through arguments and return values -> symbols
;; - Need to know symbols
;; - What about implicit symbols such as lookup by string such as hashtable
;;   - intern = string -> symbol
;;   - program exceptions?

;; - Scan src to tokens -> Analyze branches -> Schedules tasks -> Generate/exec code

;; Upon start up, pass root fn (main) to generator
;; Exec until infinite loop - constantly repeat process above infinitely
;; - Memoize results to make faster
;; - If user changes code, then it changes

;; Forms:
;; 1. Self-eval
;; 2. Symbols
;; 3. Lists
;;    1. Special forms
;;    2. Macros
;;    3. Func calls

;; Valid Forms:
;; * An atom
;; * An empty or non-list
;; * Any list that has a symbol as its first element

;; For functions, create a node
;; For functions/symbols - create successor node
;; - declare whether functions will called or control statement controls evaluation
;; Works with simple code...
;; To build function list, find all defuns
;; Need to scan all files first
;; Don't need all functions, just the ones that can parallelize
;; - or our defuns or explicit ones
;; Final DAG will help visualize fn-symbol dependencies
;; - e.g. symbols with multiple fn successors mean they share that data
;;   and threading would require locks

;; top down from root
;; node = root
;; do fn
;;   submit task for node
;;   if node has successors:
;;     submit task for each node
;;     wait for results
;;     recurse and call this fn on each node

;; sym -> fn -> sym -> fn -> sym -> ...
;; maintain this pattern
;; fn inputs not only include arguments but any symbols read
;; fn ouputs not only include return symbols but any variables written to
;; it is ambigious whether a symbol is read/written

;; input is expected reads
;; output is expected writes
;; reads and writes would be on both predecessors and successors

;; only works with code where certain guarantees can be made
;; such as for defun, are there any functions that wrap this

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; Brainstorm:
  ;; 1. Refactor server message processing to accept self-evaluating symbols

  ;; Input -> Model -|-> View
  ;;
  ;; 1. Input loop
  ;;    - push sync tasks to queue
  ;;      - must execute in order/serial
  ;;        - if user was typing they'd get random text
  ;; 2. Model loop
  ;;    - pull input tasks from queue -> funcall
  ;;      - purpose of this thread is to let input loop process events ASAP
  ;;      - funcall can submit tasks+receive result, or push sync tasks to queue
  ;;        - anims can only be done on frame
  ;;          - Ex: camera anim and node anim can run simultaneously
  ;;        - adding nodes can be done immediately
  ;;      - shm can only be modified during view since poss view process will read during that time
  ;;        - for view, to write to shm is to read from lisp data which requires locking...
  ;;        - solution -> copy data/state when putting in queue - such as for a node being modified
  ;;          - changes propogate like a dag...
  ;;          - serialize data so view loop simply copies memory
  ;; 3. View loop (callback)
  ;;    - Execute frame tasks
  ;;    - Copy from lisp to shm
  ;;      - execute tasks copy shm
  ;;      - send shm message

  ;; For input:
  ;; - Some events need to be handled in serial such as key presses
  ;;   - Users expect input to be handled in serial, at least within a domain ie mouse vs keyboard


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; POSS:
;; - Define 2 ptree's used by controller (ptree per frame)
;;   - Create new ptree for current frame before swap

;; Example: anim won't run concurrently - input, anims

;; Scenario: playing camera anim, then user moves camera, then what?
;; - A: do one - play anim, pass move
;; - B: do one - stop anim, move camera
;; - C: do both - result depends
;;   - camera may end up in different end position than expected
;; - C seems the most logical to the user

  
https://stackoverflow.com/questions/24839857/wireframe-shader-issue-with-barycentric-coordinates-when-using-shared-vertices
https://catlikecoding.com/unity/tutorials/advanced-rendering/flat-and-wireframe-shading
https://www.reddit.com/r/opengl/comments/3yrv79/simplistic_texture_less_tronlike_3d_with_opengl/

Protoform closest to Blender?
Except Protoform is optimized to draw maximum number of instances 
whereas Blender is designed to draw different types of models

Protoform focused on productivity and efficiency and simplicity

17. Vertices
    * How to represent vertices? They can't be nodes -> infinite recursion
      * Limit nodes to 2D/4 vertices...or n vertices in a circle?
      * Nodes can be seen as vertices
      * Remember, the underlying data model is a graph where 
      objects/vertices can be linked through edges so need not only use 
      planes/nodes, however, we default to them since they're the 
      simplest shape and very efficient to render (next to other OpenGL
      primitives like triangles/vertices). Many fundamental objects are 
      modeled as quads like windows, pixels, etc. In addition, they are
      the most convenient for drawing text.
        * Alternative route of differentiating objects besides shape is
        to use colors - how many colors can humans distinguish? 8? 
        rainbow colors?
        
        
IDEA!!!

Assume home environment with gaming router
- Similar to Apple HomeKit

Model process - run as dedicated server
View - any client such as laptop, desktop, mobile

View just needs to have the same program version

View same object on multiple devices
Transfer objects between devices
- Create a drop portal where stuff popups up

CAN WE REVOLUTIONIZE THE SMART HOME! (AND/OR OFFICE)

-----------------------------------------------------

First engine is called Maximum Instancing Engine -> "Maxstance Engine"
- Maximum instances
- Per-instance color/alpha/texture/UVs
  - Make these command line options
- No lighting?
- Post processing effects: motion blur
  - Focused on creating aesthetic appearance over technically correct
...

Use EVVEE for more lighting-based renderings...

Anyhow, limitations to engine is limitations to instancing

------------------------------------------------------------------------

:RULES:
- Two types of nodes: vertices and edges [binary system ;)]
  - Node is a linkable object (thus not simply called an object)
- Vertices
  - can only link to edges
    - ostensibly the user selects two vertices but automatically done
- Edges
  - can only link to vertices
  - typically not textured for optimization purposes

**If abstraction is broken, all hell breaks loose!**

------------------------------------------------------------------------

How to Design Help System

Use lisp describe method as starting point

User sees an object and wants to do something with it but does not know

Object -> What Function? -> Desired Output

Type help after it and it will print info for that node

- Use a game to teach commands? Like ad destroyer...user has to destroy
nodes as they popup...use augmented reality like pokemon
 - start with basic commands like add/delete nodes, linking nodes, eval,
 swapping nodes, toggling ids
 
 - Use it to introduce concepts for widgets/GUI so users understand
 how they work - or should animations
 
 What are the most addictive games? 
 Fruit ninja, gem stone game, pokemon go?
 
 - People like mice because it has two buttons - easy to use and understand
   - They move/hover/point at an object -> press a button -> something happens
 - Mouse's buttons (functions) act on widgets which are generally 
 standardized across programs
 - Essentially we want something like that but more powerful
 - Instead of the mouse, we use basic keyboard functions...
 
 How to combine mouse on one hand, and keyboard on the other?
 Mouse is continous whereas keyboard is discrete
 Keyboard can move 1 step whereas mouse can use physical properties 
 like velocity/acceleration
 
 22. Should pointer target be predecessor or successor?
    - Successor makes sense since pointer is like an arrow