Given:
(defun add (a b)
    (+ a b))
    
defun
|
add
|
.----a
|    b
|
.----+
     a
     b


defun add  .    .
           a b  + a b


{defun}-{add}-{.}-{.} = (defun add () ())

{defun}-{add}-{a}-{+} = (defun add (a b) (+ a b))
               |   |
              {b} {a}
                   |
                  {b}


{defun}-{add}-{.}-{.} = (defun add (a b) (+ a b))
               |   |
              {a} {+}
               |   |
              {b} {a}
                   |
                  {b}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TASK: Change argument 'a -> 'xyz

    -{.}-
      |
 {*}-{a}
      |
     {b}


Create list -> Ctrl+L (or del a first)
Enter list -> Down
Type chars -> X-Y-Z
Read chars -> Ctrl+R

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

* overwrite [NO]

(defun (() b) (+ a b))

    -{.}-
      |
 {*}-{.}
      |
     {b}

Alternative: del -> (ptr mov b) -> prepend
* Backspace would remove before ptr
* Delete would remove after ptr
* Does not make sense, since cannot build chains (lists) if constantly replacing item
* In typing, chars are added after so default to append

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

* append; pointer must move to new object

(defun (a () b) (+ a b))

    -{.}-
      |
     {a}
      |
 {*}-{.}
      |
     {b}

So from here, how to append to list contents versus adding atom after list?
Need to enter list -> Use arrow keys and then do as normal

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

How to produce (((nil)))?

{.}-{.}-{.}

>> (cons nil (cons nil (cons nil nil)))
(NIL NIL NIL)

>> (cons (cons (cons nil nil) nil) nil) 
(((NIL)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NOTES:
  
* Fundamental Commands/Shortcuts

  These are mostly intuitive

  * char   : append to list containing ptr
  * #\Space  : ...
  * #\Tab    : ...
  * #\Enter  : ...
  * #\Backspace : remove before ptr
  * #\Delete    : remove after ptr
  
  MOVEMENT (combos of link/unlink + move)
  * Up : supercede (closest semantic list)
  * Dn : infra (closest semantic list) 
    * Infra = within vs sub- = below so super/infra vs epi/sub
  * Lt : precede
  * Rt : succede  

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  These require some initial learning
  * Ctrl evals, alt prints nodes
  * Can chain so <mod> + n t # = (n t #)
  
  ATOMS
  1. nil/() : <mod>+n / <mod>+.[dot] or <mod>+c[ons] (visually represented by dot)
  2. t      : <mod>+t
  3. #      : <mod>+# (produce number instead of char; default to char...)
  
  LIST
  4. Listify : <mod>+l
    * Take ptr and place in list
    * Doing this when unlinked is same as nil/()
  5. Unlistify : <mod>+t
    * Opposite action of listify is to use first item in list (aka first)
    * Remainder is deleted or remains in list and appended after so
      * (a (b c d)) -> (a b (c d))
      
  NODES
  6. Eval-nodes-char (enc) : <mod>+e  : eval-nodes-char
    * Eval current form
    * Eval current top-level form
    * ...
    * Mimic https://common-lisp.net/project/slime/doc/html/Evaluation.html
    * Replace nodes with output (add option to retain cmd...)
    * Implies read
  7. Read-nodes-char (rnc) : <mod>+r : read-nodes-char
    * Build string from current pointer backwards until non-char and then
    input to read
    * Basically transform data -> data or chars to a string
    * When converting chars/string -> atom (aka code->data through read)
      * For non-char atoms (char count > 1), remove #\- between nodes
      * Default does not show it so poss use colors to indicate among
      char, strings, numbers and other atoms
  7.5. Print-node (wnc) : <mod>+p
    * Turn data into chars
  8. Link/unlink-nodes : <mod>+k/j (takes arg)
    * allow to create new top-level lists
    * essentially same functionality as jump (goto etc) if given ID
    * default unlinks ptr
    
  9. Open/save-nodes : <mod>+o/s (takes arg)
  
  10. Cut
  11. Copy
  12. Paste
  
  PTR
  10. Create/destroy-ptr : <mod>+*/&
  
  HYPERWEB
  11. Show/hide-ids : <mod>+i
  
  