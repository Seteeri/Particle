60 bits = 1 152 921 504 606 846 976

Systemd has effectively rewritten the Linux userland, which depending on your
interpretation, now provides a unified userland, which may be deemed most
appropriate for servers and sysadmins. However, I believe for the desktop user
and developers, it does not provide an appropriate interface, as it still relies
on C and shell scripts through ini files, which is essentially a scripting
analogue to C and a way to manage C processes/programs.

VENN DIAGRAM CIRCLES

* BSD
* Blender
* Emacs
* Evernote
* Elementary OS
* Arcane
* Interlisp-D

################################################################################

Traditionally computers have worked by having different applications and
UIs working on both different and similar data with overlapping
operations and functionality. For example, a word processor might include
some image editing operations, and an image editor might provide the
ability to rasterize text.

The idea of Protoform is to invert that model so users have a consistent
interface with less redundancy which is faster to learn. Data today is
not simply numbers and text but much more, and users need an interface
that can cut across all domains.

################################################################################

Generate glyphs for builtin symbols?
- However, if any changes made to glyphs, it would have to be generated and tex
uploaded while running

Could do the same for prose - common english words
https://en.wikipedia.org/wiki/Most_common_words_in_English
- Or analyze this dynamically as user types

--------

For images, load entire image as a texture and then break into tiles
as user works on it, 2,4,8,16,32,64 etc

Make smart process - release tile if user moves to another tile
after a certain amount of time or learn users behavior to calculate the
threshold

################################################################################

text   -> raster (texture)
raster -> text (OCR)

text     -> waveform (text-to-speech)
waveform -> text (voice recognition)

raster   -> waveform (texture)
waveform -> raster (texture)

waveform/spectrogram/bitmap

UNREAL BLUEPRINTS
- Cannot create new nodes with nodes - but we can!

https://news.ycombinator.com/item?id=14482988

################################################################################

Forward... -> Tiled -> Clustered -> Volumetric

See Volume Tiled Forward Shading is based on Tiled and Clustered Forward Shading described by Ola Olsson et. al

################################################################################

https://stackoverflow.com/questions/24839857/wireframe-shader-issue-with-barycentric-coordinates-when-using-shared-vertices
https://catlikecoding.com/unity/tutorials/advanced-rendering/flat-and-wireframe-shading
https://www.reddit.com/r/opengl/comments/3yrv79/simplistic_texture_less_tronlike_3d_with_opengl/

################################################################################

First engine is called Maximum Instancing Engine -> "Maxstance Engine"
- Maximum instances
- Per-instance color/alpha/texture/UVs
  - Make these command line options
- No lighting?
- Post processing effects: motion blur
  - Focused on creating aesthetic appearance over technically correct
...

Use EVVEE for more lighting-based renderings...

################################################################################

How to Design Help System

Use lisp describe method as starting point

User sees an object and wants to do something with it but does not know

Object -> What Function? -> Desired Output

Type help after it and it will print info for that node

- Use a game to teach commands? Like ad destroyer...user has to destroy
nodes as they popup...use augmented reality like pokemon
 - start with basic commands like add/delete nodes, linking nodes, eval,
 swapping nodes, toggling ids

 - Use it to introduce concepts for widgets/GUI so users understand
 how they work - or should animations

 What are the most addictive games?
 Fruit ninja, gem stone game, pokemon go?

 - People like mice because it has two buttons - easy to use and understand
   - They move/hover/point at an object -> press a button -> something happens
 - Mouse's buttons (functions) act on widgets which are generally
 standardized across programs
 - Essentially we want something like that but more powerful
 - Instead of the mouse, we use basic keyboard functions...

 How to combine mouse on one hand, and keyboard on the other?
 Mouse is continous whereas keyboard is discrete
 Keyboard can move 1 step whereas mouse can use physical properties
 like velocity/acceleration

 22. Should pointer target be predecessor or successor?
    - Successor makes sense since pointer is like an arrow

################################################################################

Implement NOTEPAD:

Edit:
* Undo/Redo - TODO
* Cut/Copy/Paste/Delete - Del:YES
* Select All - TODO

Search: TODO
* Find
* Find Next/Prev
* Replace
* Jump To

Options: TODO
* Font - not really feasible right now other than fixed-width/monospace
* Word Wrap - yes
* Line Numbers - yes
* Auto Indent - yes

################################################################################

Never liked the idea of the cursor being inbetween chars...
WHAT IS IT SELECTING???

CLI: Type command -> Enter (no shortcuts)
Emacs: Key chords/bindings + modes [MAX KEYBINDINGS/MODESish]
Archy: Quasimode + type command [MIN KEYBINDINGS/MIN MODES]

US: Type command -> Eval

https://academia.stackexchange.com/questions/109/is-there-any-efficient-non-linear-note-taking-software

MOVEMENT:
1. Link move (semantic move)
2. Euclidean move (discrete steps)
3. Jump move (jump to node)
  -> Requires IDs

   * Diagram:

      h-e-l-l-o---w-o-r-l-d-*

      h-e-l-l-o---w-o-r-l-d
                  *

      Case A
                  w
                  *
      h-e-l-l-o---a-o-r-l-d
                  *

                  w-o-r-l-d
                  * * * * *
      h-e-l-l-o---a-b-c-d-e
                          *

                  w-o-r-l-d
                  * * * * *
                  | | c | |  (c still linked to b and d) !-> b has 3 outputs now...
                  | | * | |
      h-e-l-l-o---a-b-z-d-e
                      *

      Case B - this would need to be explicitly done
               use command like "branch" to move "world"
               to a list

                  *-w-o-r-l-d
                  *
      h-e-l-l-o---a-b-c-d-e
                          *

                  *-w-o-r-l-d
                  *
                  |   *-c-d-e
                  |   *
      h-e-l-l-o---a-b-z
                      *

                  *-w-o-r-l-d
                  *-a
                  *
                  |   *-c-d-e
                  |   *
      h-e-l-l-o---x-b-z
                  *

      If x is deleted, then entire branch moves to undo graph

      Case C - user modifies history; undo will still track changes
               below achieves users intentions

                  *-w-o-r-l-d
                  *
      h-e-l-l-o---a
                  *

                  *-w
                  *
      h-e-l-l-o---a-o-r-l-d
                          *

      alternatives - user retypes it; user copies it

      Case D - this is implicit - "insert-node"
               this actually behaves like overwrite (insert mode) - usually used to maintain spacing
               use alt+<char> for this?

                  w o r l d
                  * * * * *
      h-e-l-l-o---a-b-c-d-e
                          *

      ________________________

                 (* w-o-r-l-d)
                  |
                  *
      h-e-l-l-o---u
                  *

      undo*----->(* w-o-r-l-d)
                 /|\
                  |
                  *
                 /|\
                  ------------------|
      h -> e -> l -> l -> o -> - -> u -> s -> e -> r
                                   /|\
                                    |
                                    *

      * If user wanted to simulate insert, multiple ways:
        - Branch text, link text (del ptr)
        - Cut text/line, insert text, paste text
        - verbose: manually unlink/move everything

                  * w-o-r-l-d
                  *
      h-e-l-l-o---u-s-e-r
                        *

      Relink "world" by typing command:

                  * w-o-r-l-d
                  *
      h-e-l-l-o---u-s-e-r-\n-l-i-n-k---i-d
                          {               }* -> eval

      Eval will unlink newline (input) and link output

      h-e-l-l-o---u-s-e-r-w-o-r-l-d
                                  *
https://softwareengineering.stackexchange.com/questions/224146/how-has-an-increase-in-the-complexity-of-systems-affected-successive-generations/224152

Moreover, let's not forget what we're actually trying to optimize for, which is
value produced for a given cost. Programmers are way more expensive than
machines. Anything we do that makes programmers produce working, correct,
robust, fully-featured programs faster and cheaper leads to the creation of
more value in the world.

################################################################################

https://news.ycombinator.com/item?id=15466124

No.

I expect this will be a fairly controversial comment, so I want to preface this by saying that I'm a big Lisp fan (just look at my handle). Lisp is my favorite programming language. I've been using it for nearly forty years. My first Lisp was P-Lisp on an Apple II in 1980. And I worked on Symbolics Lisp machines in the 1990s. They were very cool, but there's a reason they failed: general-purpose computing is infrastructure, and the economics of infrastructure are such that having a single standard is the most economical solution, even if that standard is sub-optimal. For better or worse, the standard for general-purpose computing is the C machine.

Because it's general-purpose you certainly can run Lisp on a C machine (just as you could run C on a Lisp machine). You can even do this at the system level. But Lisp will always be at a disadvantage because the hardware is optimized for C. Because of this, C will always win at the system level because at that level performance matters.

But that in and of itself is not the determining factor. The determining factor is the infrastructure that has grown up around the C machine in the last few decades. There is an enormous amount of work that has gone into building compilers, network stacks, data interchange formats, libraries, etc. etc. and they are all optimized for C. For Lisp to be competitive at the system level, nearly all of this infrastructure would have to be re-created, and that is not going to happen. Even with the enormous productivity advantages that Lisp has over C (and they really are enormous) this is not enough to overcome the economic advantages that C has by virtue of being the entrenched standard.

The way Lisp can still win in today's world is not by trying to replace C on the system level, but by "embracing and extending" C at the application level. I use Clozure Common Lisp. It has an Objective-C bridge, so I can call ObjC functions as if they were Lisp functions. There is no reason for me to know or care that these functions are actually written in C (except insofar as I have to be a little bit careful about memory management when I call C functions from Lisp) and so using Lisp in this way still gives me a huge lever that is economically viable even in today's world. I have web servers in production running in CCL on Linux, and it's a huge win. I can spin up a new web app on AWS in just a few minutes from a standing start. It's a Lisp machine, but at the application level, not the system level. My kernel (Linux) and web front end (nginx) are written in C, but that doesn't impact me at all because they are written by someone else. I just treat them as black boxes.

I don't want to denigrate ChrysaLisp in any way. It's tremendously cool. But cool is not enough to win in the real world.

[UPDATE] ChrysaLisp is actually doing the Right Thing with respect to its GUI by
 using a C-library (SDL). But it's trying to re-invent the compiler wheel (and
 the language design wheel) so that it can run on bare metal and "grow up to be
 a real Lisp machine" some day, and I think that aspect of the project is a
 fool's errand. There are already many Lisps that can run on bare metal (ECL was
  specifically designed for that). None of them have succeeding in displacing C,
  and I believe none ever will because the economic hurdles are insurmountable.

################################################################################

(defun read-64 (buf)
  (let ((u 0))
    (setf (ldb (byte 8 56) u) (aref buf 7))
    (setf (ldb (byte 8 48) u) (aref buf 6))
    (setf (ldb (byte 8 40) u) (aref buf 5))
    (setf (ldb (byte 8 32) u) (aref buf 4))
    (setf (ldb (byte 8 24) u) (aref buf 3))
    (setf (ldb (byte 8 16) u) (aref buf 2))
    (setf (ldb (byte 8 8) u) (aref buf 1))
    (setf (ldb (byte 8 0) u) (aref buf 0))
    u))

(defun read-32 (buf)
   (let ((u 0))
    (setf (ldb (byte 8 24) u) (aref buf 3))
    (setf (ldb (byte 8 16) u) (aref buf 2))
    (setf (ldb (byte 8 8) u) (aref buf 1))
    (setf (ldb (byte 8 0) u) (aref buf 0))
    u))

(defun read-16 (buf)
  (let ((u 0))
    (setf (ldb (byte 8 8) u) (aref buf 1))
    (setf (ldb (byte 8 0) u) (aref buf 0))
    u))

################################################################################

http://www.cs.cmu.edu/afs/cs/academic/class/15210-f15/www/tapp.html#ch:multithreading

Keys to Achieving Parallelism

1. DAG
2. Atomics - minimize usage of locks

Should a task that readds itself create a new task instance or reuse
existing?

https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands

From
a consumer perspective, the lower abstractions are becoming virtualized
at the convenience of the user, i.e. web browser becoming a platform.
However, the increase in data breaches and security issues have not
completely eroded the OS a key factor.

https://www.reddit.com/r/lisp/comments/9q68y8/has_the_gnu_coreutils_ever_been_implemented_in/

https://www.reddit.com/r/lisp/comments/1fj0qf/lisp_vs_haskell/

https://github.com/BusFactor1Inc/sxc

https://news.ycombinator.com/item?id=13199610

https://www.cliki.net/cl-emacs

Difference between having source code and then eval'ing it like in EMACS
versus having those live data objects accessible in the program like in
Protoform.

https://nullprogram.com/blog/2014/06/29/

Organize functions based on I/O
node -> node
text -> node

https://mattdesl.svbtle.com/drawing-lines-is-hard

http://www.osenkov.com/diplom/contents/1/4/

https://github.com/sile/taomp-sbcl

http://etodd.io/2016/01/12/poor-mans-threading-architecture/

if our engine is a particle system, how to do lighting?

must move as much code to the compute shader as possible

https://www.pvk.ca/Blog/2013/04/13/starting-to-hack-on-sbcl/

http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html

epoch
bbinit

shell = scripting language for C (processes)

########################################################################

Separate parts become a whole when it is more efficient to do so or
when the interaction of those separate parts becomes more complex than
those parts as a whole.

########################################################################

SASOS

in single address space, the language is unified and thus passing data
is unified. instead of different processes with different formats,
functions pass objects around (ostensibly passing symbols).

unix:
shell process executes C process(es) which communicate through pipes which
are implemented like a file underneath

lisp:
lisp image contains objects which communicate through functions

What we want to do is take that pipeline message passing model and build
on it by using a general purpose language to facilitate it (or build DSL)

We can go further and use DAGs to describe a pipeline that can allow
for parallelization. in this case, we hook objects including fn's
(since fn's are 1st class objects in lisp)

Imagine each C process managing memory along with interpreted languages
with their own GCs versus a single GC managing all the memory and objects.

That includes multiple levels of redundancy increasing complexity and
chances of bugs.

Does this outweigh the disadvantage of a single point of failure?

It is easier to make a single system more stable than multiple systems

However, this single system must be simpler thus easier to understand
and modify than multiple systems, which in the case of lisp vs c, yes

http://wiki.c2.com/?SingleAddressSpaceOperatingSystem

https://www.usenix.org/legacy/event/usenix99/full_papers/deller/deller.pdf

https://news.ycombinator.com/item?id=11187072
http://www.lighterra.com/papers/modernmicroprocessors/

systemd issue is cohesion and coupling - high cohesion and high coupling
high coupling being bad since indicative of high complexitty

Linux kernel-userspace: low cohesion, low coupling

area = group of nodes or leaf?
coupling is like number of edges between two given areas
cohesion is like number of nodes in a given area

the other issue is systemd is more dynamic - able to respond to events
better like hot-plugging...same is becoming more desirable in code...lisp?

GC STILL AN ISSUE...moves nodes to different memory for static objects..weak refs?

ZERO FRAGMENTATION HEAP -> LINEAR HEAP
https://library.softwareverify.com/memory-fragmentation-your-worst-nightmare/

################################################################################

Expand heap = (gc N>0)
Shrink heap = (gc 0)
Heap total size = (heap)
Heap used size = (heap T)
Avail ptr = Cons + adr

Heap address (start) = ?
Avail = ?

Start of frame, cons, store address
- To find avail, could search memory for pointer
End of frame, modify avail to original address

################################################################################

https://emersion.fr/blog/2018/wayland-rendering-loop/

convetionnal: hetero ui - hetero data (overlap)
flip:         homo   ui - hetero data (data/file types)

must provide way to work with all data - open source to start with like OpenDocument

In LISP all data is made of cons cells
In Protoform all trees(UI) are made of nodes
Nodes = cons cells

Buttons are a single node
"Clicking" (state change) is triggered by link/eval (like moving and clicking)
  or poss: pre-link+eval = read->eval, post-link+eval = quote->eval
  this would be like moving over "presses" button

  [code = str; all just bytes->bits->binary in the end ;)]

  general tree -> binary tree (diff data encodings, gen tree lowered to cons/binary tree)
  code         -> data        (diff data encodings, str is lowered to cons/bytes/bits/binary)

  read  = code -> data
  print = data -> code

  quote = data -> code (lets data be code)
  eval  = code -> data (code is what we understand; data is what computer understands)

idea is ops performed on gen tree can afterwards still convert back to cons
str is understood by humans and cons/bytes/bits/binary is understood by machines
- translate both ways is the key to understanding and efficiency/productivity
gen tree is understood by humans and binary tree is understood by lisp interpreter/eval
ui/nodes are code and data
nodes can be transformed to data so that node represents its value (unless quoted)

(setq node 0)

(when <node/data> (exit)) ; triangles = data
-> 0 (numeral)

vs

(when (node/code) (exit)) ; squares = code
-> node (symbol/string)

print = tri -> sq
read = sq -> tri

so node can represent both code and data and user can apply transformers

Link multiple times which cannot be done in binary tree
node=T
-> when
-> if
-> ...

In lisp code, this would just be a symbol refernced by all

: (scl 4)
-> 4

: (setq P (native "@" "malloc" 'N 16))
-> 10851136

: P
-> 10851136

: (struct P 'N (1.0 0.11 0.22))
-> 10851136

: (struct P (1.0 . 2))
-> (1100 2200)


https://stackoverflow.com/questions/17717600/confusion-between-c-and-opengl-matrix-order-row-major-vs-column-major

9.005 Are OpenGL matrices column-major or row-major?

For programming purposes, OpenGL matrices are 16-value arrays with base vectors laid out contiguously in memory. The translation components occupy the 13th, 14th, and 15th elements of the 16-element matrix, where indices are numbered from 1 to 16 as described in section 2.11.2 of the OpenGL 2.1 Specification.

Column-major versus row-major is purely a notational convention. Note that post-multiplying with column-major matrices produces the same result as pre-multiplying with row-major matrices. The OpenGL Specification and the OpenGL Reference Manual both use column-major notation. You can use any notation, as long as it's clearly stated.

Sadly, the use of column-major format in the spec and blue book has resulted in endless confusion in the OpenGL programming community. Column-major notation suggests that matrices are not laid out in memory as a programmer would expect.

################################################################################

* DAG/nodes IPC
  * Interop/conversion between bytes and cons a poss issue!!
    * Render does no additional processing on nodes, simply does memcpy
    * Memcpy certain amount of bytes per frame
      * Perform benchmark; dependent on computer performance characteristics
    * If render simple and mostly C calls and development static, write render
    in C

  * No shared memory? -> Later, use to increase performance as needed with memfd_create
    * Model processes nodes, serializes, puts into queue of render
    * Use socket buffer as message queue, for now...

  * To do multiple processes working on nodes, split total node capacity across
    processors
    * However, processes will need to synchronize with each other
    * To optimize, localize objects by moving between processes
    * Use PicoLisp pool+memfd_create, in this situation
      * Pool uses GIL on the file, although can lock single symbols

  * or...BUILD A GUI AROUND THE EXISTING DATABASE STRUCTURE?
    * Later, when multiple processes need to work on data and synchronize, use
      PL pool (except use memfd_create instead)
  * On top of nodes, build binary trees - lisp code/data


* Implementation
  * Graph = pool
  * Node  = external symbol
  * Modify Node, Commit Node, Notify Render Of Node
  * Number nodes node-1, node-2, node-n... and allocate among processors
    * Or one database per processor
  * Intermediate file write can be removed if memory used directly
    * Ask on mailing list about this

* If we use PicoLisp infrastructure:

  Model
  |_________________________
  |      |       |    |    |
  View-1 View-2  W-1  w-2  w-3

* If we use symbols/classes, then those would represent the GUI parts?

Latency:

Each process has a copy of objects in its local heap. Think of DB as external
heap from app perspective.

It'll be faster if we back it with memfd

* Model write DB
  *
* Render read DB
  * Update nodes when idle...

https://www.mail-archive.com/picolisp@software-lab.de/msg08887.html

################################################################################

Areas
- Have instances of Heap lists
- When wanting to use another, simply change pointers Heap and Avail
- GC remains the same
- But what if object in Heap A points to object in heap B?
  - Would still work but might be inefficient due to possibly different pages
  -> Need copying/moving/compacting solution

- Can simulate areas by processes but would have to copy objects over when
cross references exist - naturally copying/moving/compacting
  - Proc could broadcast request which any node would satisfy
  - Gives concurrent/parallel GC for free
  - Gives compacting for free also - initially copy cost must be paid once upfront

################################################################################

Each vertex has either a texture or a pixel (no texture)

################################################################################

- Default options (for auto pack/glue):
  - Num: prints bytes? ...(see below)
  - Char: user explicitly packs etc
  - Words: auto pack on enter or space (non-graphical characters)
  - Sentences: auto pack on . + non-graphical character
  - Paragraphs: auto pack on tab

- Eval=<mod>+Enter, Read=<mod>+Enter to convert code to data)

Internally, nodes are added to a timeline (maintains ref to them so no GC)
- Question - should users modify timeline directly?

################################################################################

: "X"
-> "X"
:
: (struct (+ (>> -4 (adr '"X")) 0) '(B . 16))
-> (130 5 0 0 0 0 0 0 40 203 209 14 180 127 0 0)

-So CAR and CDR are two different pointers
 ...which is probably two instances of the name then...

 Trans symbol
 - name stored directly in car/left
 - right changes with value, however, it is not nil
 - initially it is not the same as name
   -> name may be contained in another cell

:
: (struct (- (>> -4 (adr "X")) 0) '(B . 16))
-> (130 5 0 0 0 0 0 0 216 221 163 76 236 127 0 0)
:
: (struct 140652874816984 '(B . 16))
-> (216 221 163 76 236 127 0 0 216 221 163 76 236 127 0 0)
:


: (struct (- (>> -4 (adr (box))) 0) '(B . 16))
-> (2 0 0 0 0 0 0 0 72 215 66 0 0 0 0 0)
: (struct (- (>> -4 (adr (box 1))) 0) '(B . 16))
-> (2 0 0 0 0 0 0 0 18 0 0 0 0 0 0 0)
: (struct (- (>> -4 (adr (box 0))) 0) '(B . 16))
-> (2 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0)

Anon Symbol:
CAR:  0
CDR: NIL

Transient Symbol:
CAR: name (if name > 7 characters, then ptr to cons cell)
CDR: pointer to CDR of itself (points to symbol)

So CDR points to a cell which points to itself

[name|ptrVAL] ->

How to represent numbers...


ASCII = Character
Number = Character

Alt+ASCII = Type Num
Alt+Number = Type Num

Shift+Enter/Tab = Read
Ctrl+Enter/Tab = Eval

################################################################################

[user@skynet protoform]$ Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called close-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called close-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called open-restricted
Called close-restricted
Called open-restricted
Called open-restricted
Called close-restricted


################################################################################

Possible Bug! -> More like something I don't understand

input.l:

(class +Input)
(dm T ())
(dm test> () T)


main.l:

(load "input.l")

(def '*input)

(de end-main ()
  (test> *input))

(de main ()
    (push '*Bye '(end-main)))


https://news.ycombinator.com/item?id=9981874

JIT inspired by
- Pixie
- El Compilador
- Stalin
- SELF
- LuaJIT


https://en.wikipedia.org/wiki/Self-organizing_list


Launch:
* libinput
* model
* render

libinput connects to model
model connects to render

* make model the server
* libinput and render connect

libinput is one of many
view is one of many
but only one data

OpenGL::

* Triple/NoSync roughly similar to Double/NoSync

https://www.bfilipek.com/2015/01/persistent-mapped-buffers-benchmark.html

LAYOUT 1
========

I/O       CPU         I/O
Input --> Ctrl 1 <--> Model, Render
      --> Ctrl 2 <--> Model, Render
      --> Ctrl 3 <--> Model, Render
      --> Ctrl N <--> Model, Render

INPUT:  GOOD
CTRL:   ????
MODEL:  ????
RENDER: ????

Memcpy Trail
* Ctrl/Serialize, Ctrl/Socket -> Render/GL

* Input epolls for events and forwards them
  * Input not just physically attached devices/peripherals
  * Poss network I/O

* Ctrl
  * Applies functions to data
  * Pulls from Model/Update cache
  * Cache to reduce necessary copies and decrease latency
  * Pushes to Model & Render

* Model epolls for memcpy
  * Recvs data from Ctrl and updates memory
  * Broadcast updates
    -> Poss decentralize?
  * Use Redis or some other mechanism/library

* Render epolls for memcpy
  * Pushes frame time to Ctrls -> Triggers anim frame generation
  * After pushing frame, Render can either wait or continue

* Supports at least quad-core...seems like a waste to have input/model/render on
own proc
  * Poss assign to same process at the expense of latency to increase bandwith

LAYOUT 2
========

Input --> Model <--> Render

*DOES NOT SCALE!
*Ties input handling and frame handling together

* Model will respond to events through epoll
  * Input handlers write directly to render socket/queue
    * If buffer becomes full, must block recv events until render catches up
    * Input can initialize anim events
  * Frame handlers write to render socket/queue
    * This triggers animation frames to be produced
    * UDS can be implemented to drop animation frames
    * One socket per animation
      * Grouping
* Render will try recv on TCP and recv UDS
  * UDS - one datagram per socket; must process all sockets
  * TCP - iterate through sockets until empty or time limit
  * Memcpy speed is relatively constant which can be used to approximate the
  number of bytes that can be copied per frame = ~192 mb/16.7ms
    * IPC overhead like syscalls to recv/send will be an issue

##################

Animation Example:
* Ctrl:
  * Loop #0: Recv event->Handle event->Write Render socket
* Render (pre-draw):
  * Loop #1: Send time->Read sock
  * Loop #2: Send time->Read sock
  * Loop #3: Send time->Read sock

"When a new packet is received for a UDP socket that has a full receive buffer,
the new packet is dropped, even when it would be preferrable to drop the
older (buffered) packets."

* Assume UDP sized for 1 frame
  * UDP buffer size can be increased to accomodate additional frames to get latest N frames
* If render handler sends TCP then render must recv from socket until last data
* Also render, must pull all events first before executing memcpy
* Between Loop #1/2/3, if render gets frame 1 on frame 3 time, then it will still
get frame 1 time, then possibly frame 4 will be loaded next, resulting in the
middle frames being not drawn (dropped).
* Frames can be delayed or dropped
  * Per task
  * If delayed animation will appear too fast or slow...?
    -> Users don't like delayed typing which is annoying
    -> Why? Disorients users as to whats going on - defies expectations
       -> Least Astonishment Principle
* Render only draws so even if the data is not displayed, it still exists and
can be rendered anytime.

https://stackoverflow.com/questions/2963898/faster-alternative-to-memcpy


################################################################################

#{
https://gavv.github.io/articles/unix-socket-reuse/

A socket file is created by bind(2) call.
If the file already exists, EADDRINUSE is returned.

Unlike Internet sockets (AF_INET), Unix domain sockets (AF_UNIX) doesn’t have
SO_REUSEADDR, at least on Linux and BSD. The only way to reuse a socket file
is to remove it with unlink().

There are two bad approaches to deal with this problem:

#1

We could call unlink() just before bind().

The problem is that if we run two instances of our process, the second one will silently remove socket used by the first one, instead of reporting a failure.

Also, there is a race here since the socket can be created by another process between unlink() and bind().

We could call unlink() when the process exits instead.

The problem is that if our process crashes, unlink() will not be called and we’ll have a dangling socket.

#2

Using a lock file

One option is to use a lock file in addition to the socket file.

We’ll use a separate lock file and never call unlink() on it. When a process is going to bind a socket, it first tries to acquire a lock:

If the lock can’t be acquired, it means that another process is holding the lock now, because kernel guarantees that the lock is released if owner process exits or crashes.

If the lock is successfully acquired, we can safely unlink() the socket, because we’re the only owner and no race may occur.

#3
Using abstract namespace sockets

Another option is to use Linux-specific abstract namespace sockets.

To create an abstract namespace socket, set the first byte in the sun_path field of the sockaddr_un to \0. See unix(7). This socket will not be mapped to the filesystem, so it’s not possible to use filesystem permissions or remove it with unlink().

The advantage is that such a socket is automatically removed when the process exits, so there is no problem with socket reusing.

}#


################################################################################

https://datenwolf.net/bl20110930-0001/

My dream graphics system was completely abstract. Creating a window didn't involve selecting visual formats, framebuffer configurations. It was just "a window". Only when actual content is involved I want to tell the rendering subsystem, which color space I use. Ideally all applications worked in a contact color space (e.g. CIE XYZ or Lab), but sending images in some arbitrary color space, together with color profile information. Fonts/Glyphs would be rendered by some layer close to the hardware, to carefully adjust the rasterizing to the output devices properties. And last but not least the whole system should be distributed. Being able to "push" some window from one machine's display, to another machine's (and this action triggering a process migration) would be pinnacle. Imagine you begin writing an email on your smartphone, but you realize you'd prefer using a "usable" keyboard. Instead of saving a draft, closing the mail editor on the phone, transferring the draft to the PC, opening it, editing it there. Imaging you'd simply hold your smartphone besides your PC's monitor a NFC (near field communication) system in phone and monitor detects the relative position, and flick the email editor over to the PC allowing you to continue your edit there. Now imagine that this happens absolutely transparent to the programs involved, that this is something managed by the operating system.

Wayland/X11 - uses window buffer/handles
Emacs - uses text buffer

Particle - uses cons cell (buffer)

http://blog.rongarret.info/2015/05/why-lisp.html
http://blog.rongarret.info/2006/10/top-ten-geek-business-myths.html

Every atom generated is a vertex and lists are represented by edges.
-> For strings, need to traverse name cell
-> For symbols, need to traverse property list and name
-> For numbers, traverse for bignums

http://xahlee.info/UnixResource_dir/writ/lisp_problems.html

Confusing
Lisp's irregular syntax are practically confusing. For example, the difference between (list 1 2 3), '(1 2 3), (quote (1 2 3)) is a frequently asked question. The use of ` , ,@ are esoteric. If all these semantics use the regular syntactical form (f args), then much confusion will be reduced and people will understand and use these features better. For example:

(a . b) ; bad

(. a b) ; good
'(1 2 3) ; bad

(' 1 2 3) ; good
; or
(list-literal 1 2 3) ; good
(setq myListXY `(,@ myListX ,@ myListY)) ; bad

(setq myListXY (` (,@ myListX) (,@ myListY))) ; good
; or
(setq myListXY (eval-parts (splice myListX) (splice myListY))) ; good


Deep Nesting is Rare
The lisp's cons, as a underlying primitive that builds lists, even though a bit cumbersome, but works just fine when data structure used is simple. Even today, with all the Perl, Python, PHP, JavaScript etc langs that deal with lists, vast majority of list usage is just simple flat list, sometimes 2 level of nesting (list of list, list of hash, hash of list). 3 levels of nesting is seldom used, unless it is 3D matrices used mostly in computer graphics or linear algebra applications. Greater than 3 level is rarely seen. Systematic manipulation and exploitation of nested list, such as mapping to leafs, to particular level, transposition by permutation on level, or list structure pattern matching in today's functional langs, etc is hardly ever to be seen. (These are common idioms in so-called array languages. For example, APL, MATLAB, Mathematica.)

So, in general, when you just deal with simple lists, the cumbersomeness of using {cons, car, cdr, caardr, …} for list doesn't really surface. Further, the cons is fundamentally rooted in the language. It's not something that can be easily changed except creating a new language. When there is a specific need in a application, there is a haphazard collection of functions that deal with lists at a higher level.

KIND OF LIKE POINTERS, EH?

################################################################################

PTR = INPUT/EVAL

Note, when a symbol or cons cell is created, it is recursively drawn

A symbol, property list, value, name are all drawn
For symbols, a "draw" property is attached which contains the gl parameters
This property itself is also drawn in OpenGL

########################

STRING/SYM FUNCTIONALITY

Primitives:
* Create strings: ASCII keys
* Join/link strings: pack, glue, make/link (better for lists)

* Destroy strings: Backspace/Delete
  * Backspace removes object back of ptr
  * Delete removes object front of ptr
* Split strings:

* Format -> Str : Num
* Intern -> Str/T-Sym, : I-Sym
* Name   -> I-Sym : Str/T-Sym

* Sym - takes printed rep of object and turns into I-Sym; reverse of any
* Str - build string from list

STR CMD (ASCII KEY)
* If ptr=NIL: create free tsym/atom - all nodes already exist so they will not be GC
* If ptr=CAR: replace str; move ptr?
* If ptr=CDR: append str; move ptr to next CDR

# When rendered, draw reverse?

("a")
  |
  *

("b" "a")
  |
  *

("c" "b" "a")
  |
  *

# User presses shortcut to pack/glue -> use list as argument to pack - new list produced
* Three eval methods:
  Shift: Save both (def) - ignore NIL return?

Pack:
-> ("cba")

Glue-P: car used as glue, cdr as list
-> ("bca")

# User moves pointer back to original list, continues typing (or user goes to new list)

("f" "e" "d" "c" "b" a")

# Pack again

("fedcba") or ("fed" "cba")

First is expected behavior so how to create the second result?
-> Create new list by detaching pointer or command
-> Type chars, pack
-> Join lists

("cba")

("fed")

Also can do

(make (link ("cba"))
      (link ("fed"))

##################

LIST FUNCTIONALITY

Primitives:
* Create list
* Destroy list
* Join/link lists

* Free = master list or timeline

LIST CMD
* To create new list, Ctrl/Alt+Char? -> Holding ctrl while typing chars = nested lists
  (a (b (c)))
  Or alternating:
  (a (b c (d e (f))))
  * Alternative is to explicitly create a list each time which is clumsier:
    -> Ctrl+L, A, Ctr+L, B, Ctrl+L, C, ...
* Need command to destroy current list and move to top list, to reverse previous example
  * Remember directional key layout...

* ptr=CAR -> Yes, Create new list with atom
  -> Points to object
* ptr=CDR -> No, Create new list after
  -> Points to space after or between (nearest object)

##################

EVAL FUNCTIONALITY

How to type functions, args, eval?

(add (a b) (pack a b))

User types/packs:
("f" "o" "o")

Then uses eval command or types it all out and performs eval on the string

(e,v,a,l)

-> pack

(eval)

-> link list

(eval (foo))

-> do eval



User types add:

("a" "d" "d"

#################

NUM FUNCTIONALITY

Use <mod>+NUM to produce a number

Can create option for this...since it is fundamental


In README, go over how we invert the process model and how the current model
has much redundancy and overhead and wasting resources

[![Alt text](https://img.youtube.com/vi/BemmZaOyzbk/0.jpg)](https://www.youtube.com/watch?v=BemmZaOyzbk)


################################################################################

   * Implement Worker cache coherence/sync [Later] -> Work as intended without coherence
     * Workers represent CPUs with cache and Model represents main memory
     * Ctrl/worker sends to render, then sends update to model
     * Model broadcasts (minus sender ofc)
       * Copies one socket to many sockets
     * Workers will sync cache - poll until no messages
       * Workers can sync independently
       * However, workers must sync after every function
         * Alternate read from ctrl/render and read from model
       * Can also explicitly sync cache specific or all
         * Sync will be sent to all workers
         * Then wait on response from all workers
       * Worker A - cache 1/2, fn-1 used node-1
       * Worker B - cache 1/2, fn-1 used node-2, fn-2 uses node-1
         * What if B in middle of fn-2 and does not get the update on node-1
         until after fn-2 is done???
           * Solution is to pull req data from model before fn
           * If worker A fn-1 running before worker B starts fn-2,
             Worker B would have to block until A is done
         * Worker B does not know Worker A modified it and believes its cache is valid
         * Example, task 1 - update colors, task 2 - update positions
           * Need not serialize entire object, only relevant cells
         * As long as sync is performed before hand
           * If required function data known AOT, then batch pull to minimize I/O
       * What if data waiting to be updated in worker B and has already been uploaded to model by worker A,
       is updated by that worker B and overwritten in both model/render?
         -> The work A did is lost and never seen
         -> Question is whether the trigger for that task expected there to be
         possible conflict
         -> Makes sense? Instead of waiting for last operation to complete, just
         perform a new operation - either run serially or in parallel
         * Serial must wait for all workers to sync, and then runs
           * Send sync object, wait for return msg
     * Model can keep track of which process has which vertex
       * On broadcast, Model can check and decide whether to skip
         have the data in their cache only get relevant messages?
       * Might not be relevant since possible at some point, all workers will have
       complete cache of all data
     * Move most recently used data to the front of binary tree
     * For projview, currently only sending the matrix -> create fn to send entire structure
       * Ex: (get attr attr attr ...)
       * Would allow updating only specific members etc.
     * Example: To randomly color all nodes, would split among N processes
       * Each process would fetch a chunk of nodes
  * P2P method?
    * Worker broadcasts to peers and Model
      * Is Model needed? Contains initial data...
      * What if worker needs data that no one has...and how does it decide
      who will satisfy the request...or it creates it and caches it
    * If one worker is slow, then it won't get updates until later


https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glGetProgramBinary.xhtml


AVAIL PTR
(struct (+ 4379328 (* 6 8)) '((B . 8) (B . 56)))

Do size -A ./picolisp
Get .data offset
Or use NIL
Look in base.s to get offset


https://linux.slashdot.org/story/19/05/15/1523252/why-linux-on-desktop-failed-a-discussion-with-mark-shuttleworth?sdsrc=popbyskidbtmprev

#(println (format (get (: dims) 1) *Scl) (format (*/ *adv-glyph Sca-Glyph 1.0) *Scl))


LIST:
CAR=ATOM
CDR=CONS

ATOM:
CAR=<>
CDR=<>

NEED QUOTE OPERATOR
- NO QUOTE IS NORMAL
- QUOTE WILL EDIT THE REP

https://www.phoronix.com/forums/forum/phoronix/latest-phoronix-articles/1114417-wayland-s-weston-lands-a-pipewire-plug-in-as-new-remote-desktop-streaming-option/page3

Wayland and X11 are two very different things and remote desktop is one area where Wayland will always still benefit from a protocol such as X11. For example the best Wayland can do is a slow VNC type approach of sending across a complete raster image (albeit compressed) which requires a lot of bandwidth. An intelligent protocol sends across instructions such as "draw line between x and y". This is how X11 works.

Windows and RDP has even X11 beaten and is thus far ahead of VNC and Wayland when it comes to performance. This is because rather than simply sending drawing instructions, it is aware of widgets and so can send much higher level instructions such as "refresh window", "draw button here", etc.

In short... The *NIX desktop (*NOT Wayland*) needs to up its game if it plans on ever competing in the enterprise with remote desktop solutions again. This needs to be done from the widget toolkit (such as Qt or GTK+), not the underlying platform and certainly not a compositor. Something like this:

Unfortunately due to a very immature Wayland, the Linux desktop is now extremely behind and is at risk of re-entering the "hobbiest / toy" market.


################################################################################


Vertices: a b c

Particle: symbol that contains both vertices and data

Data: "abc"

https://www.mail-archive.com/picolisp@software-lab.de/msg07414.html

On Wed, May 03, 2017 at 10:24:59AM -0800, Christopher Howard wrote:
> Just out of curiosity: does PicoLisp have some mechanism for dumping the
> process image (or some equivalent effect) so you can save a PicoLisp
> process in a certain state and restart it there.


Not completely I think. What comes close would be pretty-printing the values of
all symbols (omitting circular structures which otherwise would cause a hang):

   (out "save.l"
      (for "S" (all)
         (unless (circ? (val "S"))
            (pp "S") ) ) )


On Wed, May 03, 2017 at 09:18:22PM +0200, Alexander Burger wrote:
> On Wed, May 03, 2017 at 10:24:59AM -0800, Christopher Howard wrote:
> > Just out of curiosity: does PicoLisp have some mechanism for dumping the
> > process image (or some equivalent effect) so you can save a PicoLisp
> > process in a certain state and restart it there.
>
> Not completely I think. What comes close would be pretty-printing the values
> of
> all symbols (omitting circular structures which otherwise would cause a hang):
>
>    (out "save.l"
>       (for "S" (all)
>          (unless (circ? (val "S"))
>             (pp "S") ) ) )


Having said this, I must say that I do not see a use-case.

PicoLisp starts blindingly fast by 'loadi'ng source files. And for persistence
we use the database (i.e. external symbols).

################################################################################

http://blog.rongarret.info/2006/10/top-ten-geek-business-myths.html

https://unix.stackexchange.com/questions/364641/mapping-scancodes-to-keycodes

## GC Strategies

Three primary algorithms:
* Mark...
  * Sweep
  * Region
  * Compact
* Stop/Copy (scavenging) - Cheney semi-space
* Noncopying Implicit Collection - Baker
  * Has advantages of both Mark + Stop/Copy
  * Main weakness is fragmentation...but not an issue for PicoLisp?

Mark/sweep is faster when low mortality/high liveliness since less
sweeping is done.

Stop/copy is faster when high mortality/low liveliness due to copying
all live objects.

Mark/sweep uses less space than stop/copy since stop/copy always
reserves half of the space.

Larger objects favor mark/sweep than stop/copying.

Stop/copy defragments by compacting data through copying.

Stop/copy running time proportional to amount of live objects, not the
size of the heap.

Stop/copy provides better worst-case space bounds than noncopying.

In PicoLisp, since everything is a cons cell, the GC can be optimized
around that, which favors stop/copy.

https://www.quora.com/Which-type-of-garbage-collection-mechanism-is-more-efficient-mark-sweep-or-stop-copy
https://www.hboehm.info/gc/complexity.html

Give user option:
- Expand heap
  - Can only expand until run out of memory
- Collect heap
- Fork+Collect heap
  - User must do side-effect free operations until

Scenarios

* Side effects involving resources, such as I/O, are an issue
  * Need custom syntax/fn to specify function is not pure

* Fork + Mark/Sweep
 * Fork on GC
   * Needs size of heap so mem capacity limited to half of total ram
   * Speed depends on heap size
   * Twin procs would amortize deltas at the expense of space vs fork
 * Mark-Sweep
 * Replay eval
 * Switch process
 * Misc
   * To maximize CPU throughput, do parallel mark/sweep/compact
     * Each heap/1 MB chunk
   * Partition heap into N CPU segments, join after all done

* Short Term (feasibility/suitablility, greatest->least):
  * GC not feasible/suitable -> Need semi-auto memory management
    * Per-frame Allocation
      * Runtime
        * Init/manage heap
        * Provide allocation functions - pointer bumping
          * Some allocations have to be automatic
      * On frame start:
        * avail-start = cons (or avail cons)
      * At frame end:
        * avail = avail-start
        * Any data created between those points, will be overwritten
        * For static data, memcpy to next module/frame before ptr reset
          * Copying GC basically...
      * Almost generational...
      * Create heap large enough that GC need not be triggered
        * Copy to another process while previous GC's
    -->> Modfy heap function to take a number that will set the avail pointer
    * For now, make heap large enough to prevent GC
      * Can track usage (+/- 1 MB granularity) after every eval
      * Inform user, ask to GC or resize heap
    * Hooks
      * Runtime allocates enough for default/protected symbols
        * Namespaces are like areas?
      * Alloc functions need heap pointer to allocate/link cons cells
  * TODO
    * Remove checks from cons* fn's in GC to disable GC mark/sweep
      * Maybe have function that swaps pointer functions
      -> Need it as backup if memory is full
    * Add function to get/set Avail ptr
      -> Modfy heap function to take a number that will set the avail pointer


## RESEARCH

DL
https://www.youtube.com/watch?v=R7EEoWg6Ekk

https://academia.stackexchange.com/questions/109/is-there-any-efficient-non-linear-note-taking-software

Write PicoLisp ("A") interpreter in PicoLisp ("B") -> AKA meta-circular interpreter
Have A do optimizations:
- AST rewriting
  - Replace optimized nodes with machine code

http://doc.rix.si/cce/cce.html

Biggest emacs issues:
1. Concurrency - operations/fns locking up interactiveness
2. C Core

Javascript Engines
1. QuickJS
2. ducktape
3. Jsish

https://news.ycombinator.com/item?id=20411154

################################################################################

We can create screens...but make them nodes also

https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/

Should write down cases and use as tutorials/examples

################################################################################

https://www.mail-archive.com/picolisp@software-lab.de/msg07287.html

> (list (box) (box) (box))
> ...
> ($177760526373112 $177760526373114 $177760526373116)


> Where each memory location is two more than the previous. I am wondering

Yes. BTW, these are actually cell addresses, not bytes. The values have to be
multiplied by 16 to get the physical addresses. And the value is printed in
octal representation.

Two cell are created for each symbol here, one for the symbol itself and one for
the list being built.


> if this behavior is guaranteed to always be the case, the implication

The observed offset of two is not guaranteed. Cells are picked sequentially from
the heap in the beginning, but from the Avail list after garbage collection, and
are not predictable.


> being one could have random access to any cell provided he knew the
> address of the first cell.

Correct. There is even a function for that, 'adr':

   : (box)
   -> $377166006651

   : (adr @)
   -> -34256457129

   : (oct @)
   -> "-377166006651"


  #{

      1. (X) . (()   Fn))
      2. (X) . (Ctrl Fn))

      Problem! -> 1 is always found first so 2 never executes

      Bitmask?

      1. (X) . ( (()   Fn)
                 (Ctrl Fn)
                 (Alt Fn)
                 (Shift Fn) )

      Hold Ctrl, Press X

      1. assoc ctrl -> no exist
      2. assoc x    -> list exist, assoc x list, check times
  }#


(+ 1 2)
"(+ 1 2)"
+ 1 2

+
Intern
1
2
Eval

################################################################################

 * Lists/Molecules: Pointer Ctrl
   * Currently pointer is first element in the list
   * Select items (pt/ref/link)
   * Transforms - apply to pointee
     * Move/Drag/Teleport items
       * Test touch input; need unproject
       * Animate movement? Fade in/out?
       * @ <loc> = moves ptr to it

 * Camera Ctrl
   * Center
   * Fit <list of objects>
   * Pan
   * Zoom

 * Timeline
   * Undo
   * Redo
   * If undo occurs and there is CDR, branch
     * Modify Ctrl-Z if this behavior is not wanted
       * Either through modifier or pointer structure
   * Dumping the heap - make external symbols?

 * Create default environment
    * Draw frame time, heaps, etc.
    * Draw procs -> pico ns -> symbols, timeline
      * Draw bindings
    * Draw lists downward

 * Load source code
   * Turn into strings
   * Then test symbols
     * Symbols that already exist - get existing


- Need to work on spreading load across fingers
- Programming is rarely pure typing

https://www.osnews.com/story/18829/pt-i-spatial-memory/

################################################################################

DISPLAYS

list
- horizontal
- vertical

special

- de
  (de add (a b)
    (+ a b))

- let
  (let (a b
        c d)
    (+ a c))


- for, loop, while
  (for (I 0
        (< I 10)
        (inc I))
    I)

- if, cond, when
  (if (= A 1)
      NIL
      T)

################################################################################

Poss to draw structures directly by traversing pointers

However, must store vertices somewhere

Another issue is if cell is garbage collected, no way to know, thus cannot free
vertices. So if vertices were stored in an assoc list - ptr:verts, have no way of knowing.

User must explicitly add/remove data

DATA: [.|.] -> [.|.] -> [.|.]
      |        |        |
REPR: [.|.] -> [.|.] -> [.|.]

Particle
- Dat (CAR)
- Lnk (CDR)
- Verts

(list 1 2 3)

Particle 1
- 1
- Particle 2 = (2 3)
- [1]

Particle 2
- 2
- Particle 3 = (3)
- [2]

Particle 3
- 3
- NIL
- [3]


################################################################################

Ctrl tab will make cons
- For now, create on new line

Up/Down - move between cons
Left/Right - move between atoms

( T (a b c (d e f) g) (1 2 3) T )

.
  T
  . a
    b
    c
    .
      d
      e
      f
    g
  . 1
    2
    3
  T


(de add (a b) (+ a b))

(de add (a b)
  (+ a b))

.
  de
  add
  .
    a
    b
  .
    +
    a
    b

Default to code blocks like paredit

Treemap

Graphs are inefficient for scaling

http://www.cs.umd.edu/hcil/treemap-history/

################################################################################

#{
  CMDS:

  Unused:
  CTRL/ALT/SHIFT+TAB, CTRL/ALT/SHIFT+ESC, CAPS
  * Use modifiers to modify fns?

  Identity:
  Make-Char (aka trans sym) = ASCII+PACK
  * How to input strs directly?
  Make-Num = CTRL+NUM
  * How to input multi-digit numbers directly?
  Make-Int-Sym = ASCII+CMD(PACK+INTERN)
  * How to input directly?
  Make-Cons = SHIFT+TAB

  Combos/Variations:
  Pack+Intern: cmd-intern-2
  Pack+Format: cmd-format-2

  Identity:
  Del/Rem = DEL/BACKSPACE
  Eval = ALT+ENTER
  Cut:   move ptr->buffer(Stack/LIFO)
  Copy:  dup ptr->buffer(Stack/LIFO)
  Paste: move buf->ptr(Stack/LIFO)

  Position
  Cam: Ctrl+HJKL or CTRL+Arrow
  Ptr: ALT+HJKL  or Arrow

  Transformers:
  Intern:        T-Sym->I-Sym
  Sym+Quote:     I-Sym->T-Sym
  Pack/Cut/Chop: T-Sym->T-Sym
  Format:        Str<->Num


  MOLECULAR:
  Create empty list
  Push
  Pop
  List - by default, everything is already in a list

  ESC: Clear entire timeline
}#

################################################################################


#{
  Camera
  - Dir keys
    - secondary usage
    - context switch to dir keys shifts users mind to camera instead of content
  * Pan - Alt+
  * Zoom - PG-DN/UP or Ctrl+UP/DN
  * Extent - Shift+

  Pointer
  - Select+Place be different pointers?
  * Place (mode) - R-Ctrl + WASD
    - Horizontal = *
    - Vertical   = ^ or ** or @
  * Select - R-Alt + WASD

  Strings
  * Cons/New (ASCII)
  * Pack
  * Chop?
  * Intern (-> Sym)
  * Any (-> Str)

  Symbols
  * Cons/New (through Strings)
  * Sym (-> String)

  Numbers
  * Cons/New (Alt+#)
  * Pack
  * Format (<-> String)

  List/Cons
  * Make NIL/()/''
    - option to enter new list after creation - default is NO so pressing
    new list repeatedly will create list of lists rather than nested lists,
    hmm technically lists are just nested cons
  * Split
  * Append/Conc (n/d)
  * Reverse

  Eval

  ##################################

  Non-Shift Keys:

  Shift is primary - destructive
  Alt is secondary - non-destructive

  OR

  Alpha Keys:

  * Excl WASD e.g.
  * Ctrl is primary - destructive
  * Alt is secondary - non-destructive
  * Numerics use Alt for num input
  * Layout is non-mnemonic to be consistent - all of them
  can't start with the first letter due to conflicts
  * Higher freq cmds closer to WASD like base commands
  * Place opp. funcs contiguous
    * Use same button and auto convert?

  Q = Pack (destructive)
  ? = Glue (default to space or do after space)

  E = Eval (non-destructive)

  F = Any (destructive) - Str -> Any
  G = Sym (non-destructive) - Any -> Str

  H = Intern (destructive)

  T = Format (destructive)

  Y = Reverse/Flip

  Enter = List
  Tab   = Cons
  Space = ?
  Caps = ?

  TAB = help
}#

################################################################################

https://news.ycombinator.com/item?id=15466124
https://news.ycombinator.com/item?id=1878220


 sedachv on Nov 7, 2010 [-]

Lisp Machines are something that you think is really cool when you first learn about them, then you come to the realization that pining for them is a waste of time.

I've had a flash of inspiration recently and have been thinking about Lisp Machines a lot in the past three weeks.

But first, a digression. There's an important lesson to be learned about why Symbolics failed. I think Richard Gabriel came to the completely wrong conclusion with "Worse is Better" (http://www.dreamsongs.com/WorseIsBetter.html). There are two reasons why:

1. Out of all the LispM-era Lisp hackers, only RMS understood the value of what's now known as Free Software. (If you haven't read it yet, read Steven Levy's Hackers - it describes the MIT/LMI/Symbolics split and how RMS came to start FSF and GNU).

2. Portability is really important.

The key lesson to draw from Unix isn't that "Worse is Better," it's that survivable software is Free and portable. Free because getting software to someone's harddrive is 80% of success, and portable because you don't know where people will want to use your software (there are some really weird places).

Symbolics was neither. If Genera had been Free Software, it would by definition still be around today. If Genera had been portable, it's likely Symbolics would never have gone out of business (the Alpha virtual machine would have been done sooner, with less resources, and for more systems).

Being released as Free Software today wouldn't help. Genera's predecessor, MIT CADR, was made available under an MIT-style license in 2004 (http://www.heeltoe.com/retro/mit/mit_cadr_lmss.html). There's a VM emulator which runs the code. The whole system is pretty useless.

Now on to the inspiration part:

It's possible to make a very high-performance, portable Lisp operating system on modern hardware. This has been a possibility ever since the Pentium came out. The main bottleneck to conventional Lisp runtime performance is the way operating systems manage memory allocation and virtual memory.

A type-safe runtime that has control over memory layout, virtual memory, and is aware of DMA can provide extremely high throughput for allocation and GC (this has been shown by Azure's Linux patches for their JVM), true zero-copy I/O, almost optimal levels of fragmentation, and excellent locality properties. If you go single address space (and there's no reason not to) and move paging into software (object faulting and specialized array access), you've also eliminated TLB misses.

Throw in the fact that it now becomes trivial to do exokernel-type stuff like for example caching pre-formatted IP packets, and it should be possible to build network servers that have throughput many times that of anything that kernel/user-space split OSes like Linux or FreeBSD are capable of for dynamic content (ie - not just issuing DMA requests from one device to another).

The only problem is device drivers. Lisp doesn't make writing device drivers any more fun, or reduce the number of devices you have to support.

What to do?

The reason I've been thinking about this is that I came across this: http://www.cliki.net/Zeta-C

I've heard of Zeta-C multiple times before, but for some reason this time I made the connection - "why not use Zeta-C to compile an OS kernel?"

I explored the idea further, and it seems to me that it wouldn't be an unreasonable amount of work to take the NetBSD device subsystem and have it running on top of a Lisp runtime with the necessary emulation of those parts of the NetBSD kernel that the drivers depend on. If you don't know, NetBSD's device drivers are modular - they're written on top of bus abstraction layers, which are written on top of other abstraction layers (for example, memory-mapped vs port I/O is abstracted). So the actual system twiddling bits can be neatly encapsulated (which isn't necessarily true for Linux drivers, for example).

I'm aware of Movitz (http://common-lisp.net/project/movitz/) and LoperOS (http://www.loper-os.org/). Movitz makes the mistake of trying not to be portable, but there's useful things there. I haven't spoken to Slava about this yet so I don't know what's going on with LoperOS. I am also aware of TUNES, and think it was an interesting waste of time.

The main thing is to get Zeta-C to work on Common Lisp. Then it's to build a new portable, boot-strappable runtime (I think the Portable Standard Lisp approach of having a SYSLISP layered on top of VOPs is the right way to go for this), and either build a compiler targeting that runtime, or adapt the IR-generating parts of one of SBCL, CMUCL or Clozure. Further bootstrapping can be done with SWANK and X11 once a basic networking stack is in place. I think such a system would be quite fun to hack on.

If you've gotten this far, let me know what you think about this idea. I also have some preliminary thoughts about how this can be worked into the base of a new high-performance/scalability transactional database startup, if you want to hear about that email me: vsedach@gmail.com


########################################################################

User uses symbols/lists/numbers to interact

Default Particles:
* Pointer symbol = <ptr>/PL (so eval ptr returns the CAR)
  * Multiple pointers possible?
  * Pointers pointing to pointers ad inf.? -> Also possible
* Time symbol = list/PL
  * Undo/Redo is not recorded directly since it is literally displayed
  through the list itself
* Space symbol = list/PL
  * Buffer symbol = list/PL or in lieu or list/queue, circular list, fifo, binary tree, skip list etc. (with approp. fn)
* Spacetime symbol = list/PL
  * List of Fn(In)=Out
  * Analgous to command line interface
    * Time list refers to fns
    * Space list refers to data (in/out)
      * Space:     A ---- B ---- C
      * Spacetime: A fn-1 B fn-2 C
      * Time:        fn-1 - fn-2
  * (list in fn out) - alternate or create data types
    * in = input for eval
    * fn = form to eval
    * out = result of eval

When data is created, such as through key presses, the output is added
to the space symbol list, and the cmd(input) is added to the time symbol list.

Time Sym:
create-char(NIL)=A [or NIL is Space sym itself]
  (move-ptr)
create-char(A)=B
  (move-ptr)
create-char(B)=C
  (move-ptr)
cut-char(C)
  (move-ptr)
cut-char(B)
  (move-ptr)
cut-char(A)
  (move-ptr)

Space Sym:  A B C
Buffer Sym: C B A

Undo-1 = reverse cut-char:
Time Sym:  ( Create-... ((C-C C-C C-C) (P-C)) ... )
Space Sym:  A B
Buffer Sym: C B

Undo-2 = reverse cut-char
Time Sym:  ( Create-... ((C-C C-C C-C) (P-C P-C)) ... )
Space Sym:  A
Buffer Sym: C

Undo-3 = reverse cut-char
Time Sym:  ( Create-... ((C-C C-C C-C) (P-C P-C P-C)) ... )
Space Sym:
Buffer Sym:

On undo, branch will be created:
            *
r r r u u u
->
          *
(r r r  u u ((u)
             (p)))

        *
(r r r  u   ((u u)
             (p p)))

     *
(r r r      ((u u u)
             (p p p)))


Then if user, types chars again, starting from above:

(r r r ((u u u)
        (p p p)
        (r r r)))

[Looks as though three different timelines occured]

OR

(r r r ((u u u)
        (p p p r r r)))

[Makes most sense since ppp is new timeline]

(r r r ((u u u)
        (p p p))
        r r r)

[Not sure how to interpret this...]

Timelines are naturally a binary tree.

Undoing again...

(r r r ((u u u)
        (p p p ((r r r)
                (d d d *))))) = (A B C)

#########
Question: How to select subitems in a list?

For example, select entire list to select all items. In this case, user
need not create new list, and can simply use existing list

So user must create new list with subitems. How those subitems get into
the new list can be done any number of ways:
* head/tail, then cut/head/tail


Now, we don't want to move items around with pointer - complicated and
inefficient so pointer symbol has a property, buf-cua which has the value
of a list, which it will push/pop to/from.

buf-cua is simply a list visible in another space. ofc it could be
list/queue, circular list, or fifo, or something more advanced like a
binary tree with custom function, or skip list etc.

Pointers can also point to pointers ad inf so functions will be applied
recursively so user can use a master pointer pointing to subpointers
which point to the actual targets to select specific subitems

#########
Question: How to anchor this buf-cua? ...so that data moves around it,
never on top or below.

Solutions:
-> Avoidance through collision detection? Requires moving objects
-> Use transparency to indicate it?
-> OpenGL viewports [best solution]
   - Requires rendering each viewport
   - Draw border also
   - Can viewports fit into the standard model???

########################################################################
########################################################################

lst-ptr:
* current list to push to

lists-ptr:
* list trail
* pushed to when new list created or user moves down
* popped from when current list destroyed or user moves up

* List always exist to push to
* Default is the space list
  * Has PARTICLE sentinel
  * Time list uses same senintel
* Draw on startup

* NOTE, Space and Time are both particles themselves
* The symbols that reference them are a priori (otherwise they would be
garbage collected)


* We are drawing the data which is the result from evaluating the code
* So if the code is (def *list (list 1 2 3)) -> *list
* And then evaluating a symbol, results in its value, so *list -> (1 2 3) [depends on the rule like if its a num]
* Thus we draw all the symbols, for the user to know what the value of
symbol is, use val...but how to associate the symbol to its
value...use cons cell?
  * User can build table/mapping?
  * This seems redundant though...
  * Already attempted to draw all the cons cells by tracing pointers
    * GC was the issue
    * No way of knowing when the object was GC'd so could not remove it
    * Thus the current method of particle -> data, so if particle is
    removed, then data will be removed automatically

* To do layout, iterate through remainder of list


# Must create particles for all default symbols
# Then push to Space list
# However, do not push to Time list?
#   Poss push to list before sentinel

# Is *part-ptr a particle?
# I.e. *part-ptr refers to a particle
# Where else to ref particle?
# Must be a root particle/list to reference them all
# Symbol -> Particle/List -> Particle/Symbols/List


########################################################################
########################################################################

WASM is trying to abstract OS's, however

The solution is not to build yet another abstraction on top of the OS's
different models, but to fix the underlying problem.

The solution to fix the underlying problem of different models is
connected to open-source as the proprietary models became dominant
first, i.e. Windows


If we can interpret fast enough, that relies on source code available
which makes the platform inherently open-source

The security model on desktops and phones need to be fixed, but that
also connects to companies and "walled-gardens"/vendor lock-in.

And that ties further down to having open-architecture which
hopefully RISC can fix

Emacs and Blender provide the most useful examples of success of
communities coming together around a single paradigm
- They are also very specific niches

However, as users become creators and not just consumers, tools like
Blender will become popular to the masses.

The remaining issue is whether its GPL license will affect its
adoption in the long run - which is why Cycles is permissive.

We can build around its data model from the blend file which is not
licensed.

Lisp's success relies on open hardware and hardware GC

Later we can transpile WASM to PicoLisp

Would a game engine like Half-Life be similar?
- Mods/Plugins/Extensions

Web provided a standardized data structure - the DOM - WASM throws this
out. People wanted to do more, so Javascript was invented.

At the end of the day, it comes down to the memory model...WASM will
allow different memory models, but at what cost? An inconsistent system
which creates vulnerabilities?

Apple's walled garden but not be all evil as they restrict what can
and can't be done to provide a consistent user experience...if only
there was an open-source version of them...

########################################################################

Normal is draw across

(let a (+ 1 2)
  T
  T
  T)

[let|.] -> [a|.] -> [.|.] ---------> [T|.] -> [T|.] -> [T|N]
                     |
                    [1|.] -> [2|N]

(let a (+ 1 2) T T T)

. let
  a
  . +
    1
    2

VS

. let
  a
  . + 1 2 3 4 . list 5 6 7

- all understood to belong to same list
- what if list? go down or across?
  -> becomes inconsistent


(let a (+ 1 2 3 4)
  (list 5 6 7))


[let|.] -> [a|.] -> [.|.] ---------> [.|.]
                     |                |
                    [1|.] -> [2|N]   [5|.] -> [6|.] -> [7|.]


[let|.] -> [a|.] -> [.|.] --------->
                     |
                    [1|.] -> [2|N]

   [.|N]
    |
   [5|.] -> [6|.] -> [7|.]

- Con cells cannot overlap
- Nor can lines overlap/cross as they would be same as windows on top
of each other...

(let
    a (+ 1 2)

    T
    T
    T)


[let|.]
     |
    [a|.] -> [.|.] ------------------> [X|.]
              |                           |
             [+|.] -> [1|.] -> [2|N]   [X|.]
                                          |
                                       [X|N]

(let
    a (+ 1 2)

    (list T T)
    (list T T)
    (list T T))

[let|.]
     |
    [a|.] -> [.|.] ------------------> [.|.] --------> [.|.] --------> [.|N]
              |                         |               |               |
             [+|.] -> [1|.] -> [2|N]   [list]-[T]-[T]  [list]-[T]-[T]  [list]-[T]-[T]


HOW TO DISPLAY MORE COMPACT - OR VERTICALLY

let ------------------ bindings --------------------- prog/body

[let|.]
     |
    [a|.] -> [.|.] ------------------+
              |                      |
             [+|.] -> [1|.] -> [2|N] |
                                     |
                                     +-> [.|.] --------> [.|.] --------> [.|N]
                                          |               |               |
                                         [list]-[T]-[T]  [list]-[T]-[T]  [list]-[T]-[T]

                                              (show vertically?)

(let (a (+ 1 2)
      b (+ 3 4))
  ...)

Expanded:

					       OR
[let|.] -> [.|.] ------------------------------+--->
            |                                  |
           [a|.] -> [.|.]-------------------+  |
                     |                      |  |
                    [+|.] -> [1|.] -> [2|N] |  |
                                            |  |
            +-------------------------------+  |
            |                                  |
           [b|.] -> [.|N]                      |
                     |                         |
                    [+|.] -> [3|.] -> [4|N]    |
                                               |
  +--------------------------------------------+
  |
 [T|N]


Simplified:

			   OR
let -> . ------------------+---->
       |                   |
       a -> . ----------+  |
            |           |  |
            + -> 1 -> 2 |  |
                        |  |
       +----------------+  |
       |                   |
       b -> .              |
            |              |
            + -> 3 -> 4    |
                           |
  +------------------------+
  |
  T  (this part can be here or to the right

Condensed:

let -> . ->>>>>>>>>>>>>>>>>
       a -> . -----------+
            + -> 1 -> 2  |
       +-----------------+
       b -> .
            + -> 3 -> 4

(normally, second dot should be under let but here it is draw horizontally)

  .
    let . ----------> .
	 a .           fn-1 a1 a2 a3
             + 1 2    .
         b .           fn-2 b1 b2 b3
             fn 3 4   .
    .                  fn-3 c1 c2 c3
      + 1
        2
    .
     + 3
        .
          + 4
            5
        .
          + 6
            7


  . [1|.] -+
           |
    +------+
    |
    [2|.] -+
           |
    +------+
    |
    [3|.]

let as a normal list would be:

  . let
    . a
      . + 1
          2
      b
      . fn 3
         4
    . + 1
        2
    ...

Vertically oriented:

 [.|.]
  | |
  a |
  +-+
  |
  |

 [.|.]
  | |
  b |
  +-+
  |
  |

 [.|.]
  | |
  c |
  +-+
  |
  |

==

(let (a (+ 1 2)
      b (fn 3 4))
  (+ 1 2 3)
  (+ 3 (+ 4 5) (+ 6 7))
  (1 2 3))

(let (a (+ 1
           2)
      b (fn 3
            4))

  (+ 1
     2
     3)
  (+ 3
     (+ 4
        5)
     8
     (+ 6
        7)
     9)
  (1
   2
   3))

* probably best to break lines when length >= 4
  - lines too long = eye loses tracking
  - lines too short = waste eye tracking vertically as easier to scan horizontally
  - high code density increases anxiety in the viewer

however, previous is still readable since user expects list to continue rightward or downward

for lists/funs:

  . list 1
         2
         3

  . add 1
        2
        3

for special number lists:

  . 1
    2
    3

for empty list/NIL

  (list NIL NIL)

  [list|.] -> [.|.] -> [.|.] -> NIL
               |        |
              NIL      NIL

  . list NIL
         NIL

- it is always understood, for lists, the first items are always to the right of the dot
- after that, lists either continue downward or to the right
- empty list points to nil

- problem - don't know relationship from a . to b
  ...but let statement identifies relationship...
  ...without lines, difficult to follow when code gets longer...
  ...or is that a code smell ...

- initially draw lines since easier to understand?

- if first item is placed directly under then difficult to distingish items in that list and items in the parent list
- if first item is placed directly right then difficult to distinugish items in that list and items in the parent list should all the items be placed right

################################################################################

Read macros ony apply to strings?

http://pages.cs.wisc.edu/~psilord/blog/28.html

#{

  Default to X layout because of strings
  - Can we mix layouts? Will it confuse the user?

  CAR can be either dir; top-bottom, left-right

  Place dot middle when vertical?
  -> No, destroys grid layout

  X:

    CAR·CDR -> CAR·CDR -> NIL
    |          |
    1          2

  Y:

    CAR·CDR - 1
        |
    +---+
    |
    CAR·CDR - 2
        |
    +---+
    |
    NIL

  Finally layouts can be defined for specific forms, e.g. let, if, cond, etc.

}#

cryptorick
KVMap.l


      * Dir keys move through atoms or list
        * L/R: Prev/Next atom
        * U/D: Enter/exit list
      * When typing characters, layout horizontally
        * If list starts with a string, layout horizontally
        * Store layout type in the particle
      * Anything after/below the list must be updated
      * All data belongs to master list so lists should not overlap
      or be in arbitrary places
      * Store pointers to ends of list to speed up, similar to make/link


 a        b        c
[.|.] -> [.|.] -> [.|.] -> NIL

 a        b        X        c
[.|.] -> [.|.] -> [.|.] -> [.|.] -> NIL

(conc (a b) (x) (c ...))

Must break B-C by modifying the nth's CDR

Con will modify first cell of lst's CDR to point to Any

So append is like (con (nth <last>) (""))


The issue is how to draw the symbol.


OS DEV:


PTR
 |
[.|.] -> [.|.] ->  [.|.] -> NIL


How to tie PTR symbol to the list
Ptr has the property which is the actual obj
We would need to draw the entire symbol and property list
Or pointer is simply a cons

(def *ptr (cons NIL <obj>))

Cannot draw entire symbol without shrinking it
If symbol prop list grew, could not fit it

DO:


PTR-1 -> PTR-2

PTR-2 -> DATA

...


Solution:

Draw object master pointer property list value with quoted symbol "p-1"
- Or master pointer is simply a list of quoted symbols and/or nested lists

+Pointer
-> '(p1...)

Draw symbol "p1" above actual data
- This symbol's value is the data - the symbol itself is not an object

 p1
 |
[] [] [] []

Thoughts:
* Draw pointers objects elsewhere and generate p# symbols
* Pointers can point to other Pointers
  * Check for type of object when using data

Or

Draw symbol/object elsewhere and
draw the symbol on top of the pointed
Use ... to indicate n-cells between CAR and pointed

- Okay to draw same data
-> This breaks consistency?
- If additional objects are drawn between lines then
spacing is irregular, and the only way to mitigate that is
to draw lines between cells - use single line (pipe) rotated+scaled
- It would also require moving objects around
- Draw between cells


Or

Shrink entire symbol/object to fit - use can zoom in to see it

=============================================

Type wherever, like right in the main data, and execute a command or
to be more organized, create a special list stored in an arbitrary
symbol that is used
typing commands

=================================================
=================================================

- Create Pointer class
- Draw Pointer object as part another list...
  - Property: list of syms that point to desired data
- Draw condensed sym with value below
  - Exception to the rule
    - Sym is primitive type so not so bad? Limit number of exceptions to the rule
  - Drawing a line will help understanding
  - Color to differentiate specialization/exception?
  - CDR is typically to the right, but make this exception or use marker to indicate the CDR is below
- Instead of storing properties in symbol, create class, since symbol props are not
draw entirely when above data
  - The value of objects are themselves (or their types)

Multiple pointers will stack which would require moving lines around it
-> Requires spatial data structure for efficiency

- Poss only move affected parts...but need to draw lines to maintain
relationships
  - More explicit, closer in line with user expectations - principle of least astonishment

...
D-D-D-D-D-D-D-D-...

P0    P1
P0    P1
P0    P1
|     |
D-D-D-D-D-D-D-D


vertical   = nested list - scanning vertically determines depth of list
horizontal = same list   - scanning horizontally determines breadth of list


################################################################################
################################################################################

Can't store transient symbols in particles directly...

Symbols can be drawn multiple times so should always be a list

Particles only contains roots

PROBLEM:

Data: (1 2 3 4 5 6)
Part: (1) -> (2) -> (3) -> (4)

After appending need to update all particles before it!!!
Use *particles to map particles to data

Should iterate through data not particles


Delete particle in arbitrary list
-> Deletes particle in particles - DONE

So particle should not have a/b - instead look up in particles


  (c (a b))
                     [a|*]    [b|*]    (SYMS)  a b
                       |        |
          [c|.]      [.|.] -> [.|/]    (CONS)  (a b)
            |        |
  Abst:   [.|.]  ->  [.|/]                     ((a b))

           ^          ^
          / \        / \
           |          |

  Conc:    P     ->   P    ->   N

           P          P    ->   P   ->   N

                      P         P

  (struct (>> -4 (adr *l)) '((B . 8) (B . 8)))


Maybe make all particles objects with property pointing to data
Modify data -> Modify particle
particle/sym ref data

Particles can reference each other spatially
Underlying data reference each other semantically

##################################
##################################

Maintain a pointer for every list?
Or when moving to a new list, make a pointer automatically

##################################

Differentiate behavior for pointer/list creation
* There exists special command to create NIL - maybe Enter/Return
* Creates NIL object like any char
* Must enter list to switch to it and append items
  * User can "attach" pointer to current list with cmd -
  this is really just creating a new pointer...
  * This allows user to differentiate whether they want to treat NIL as a list
  or a symbol
  
* Pointer management
  * User has master pointer in pointer list which points
  p0
  (p1 p2 p3 p4 p5 p6 p7 p8 ...)
  * Accessed programmatically or numerically
  * User can switch between manipulating p0 or whatever it points to
  * If pointer points to a pointer...either get last pointer or subpointer...
    * Traverse like a list/cons using arrow keys

Editing middle item will cause chain reaction of position updates
* If list is vertically split, then each item is updated
* Then these updates must be done piecewise since for a very long list
it would block

The lisp code itself is a scene graph

Mixing list orientations will be messy

The drawing layout is actually grid based, based on the adv width and nl height

Set limits:
Strings = 72 (PEP)
Lists/Atoms (non-str) = 12

Drawing vertically, any post lists need to be redrawn
- cache the list traversal should help with this

tree view (aka windows dir) is most familiar to people

see apse

KEY FEATURES FOR NOTE-TAKING/PERSONAL KNOWLEDGE DATABASE
* Local
* Search
* Sync
* Web Clipper
* ScanTailor
* Collaboration
* Native - wait for pil21; until then, create web version
* Export data to plaintext, PDF, Markdown, ODF/ODT

* PDF/Markdown/RSS


CALL THE DEVICE A NOTEBOOK

https://news.ycombinator.com/item?id=19552221
If you practice GTD like me, you need a trusted repository for capturing
   your thoughts, items, todos, etc. It should be fast and easy and available
   everywhere. Thats The value prop that EN brings to the table. No matter
   what it is you want to capture and store, no matter what platform, they
   have a way to quickly and easily do it. You can even email notes right into
   it (they give you a special email address) which I use for things like tech
   newsletters and stuff. So while you are right that notes apps have been
   around, its the little things that really make the difference here.



TODO: Matrix for Competition Pricing

Smartphones are diverging in functionality?

Create "Particle devices" when we get web browsing ability

How to reference object B from object A text?
- ext sym name
- tags...all...or use specific title tag if available
- both?

+Note # or Node
tg:()     #list of tags; always simple symbols/strings; order matters like when searching
nm:"..."  #opt; used for linking, else raw sym used
data:"..." #data; only string? ...later img/aud/vid
date:
desc:

#############################
#############################

IF A METHOD USES AN OBJECT...
MAKE IT A FUNCTION

#############################
#############################

BUG?...
(let Data '(NIL)

Heavy usage of javasript causing web to lose accessibility since
the DOM provides a standard structure easily parsed - the DOM is
data, not code.

https://itnext.io/why-are-we-creating-a-javascript-only-world-wide-web-db8c3a340b9

part-main = [CUR old old old ...]
all these lists are ref'd from elsewhere, master or intra, to prevent GC

Separate command to create root list

So the question is whether user can create new roots
or all new objects/lists are sublist of root
-> KISS, use latter
so part-main should never change

Next issue is how to handle modifying layouts of nested lists
Could flatten and use linking (pointers)
-> Tree/graph data difficult to manuever?

Single edit would cause chain reaction of redraw
To optimize, create list at end then move

Two main orientations:
* Desktop - Widescreen so favor horizontal
  * Layout like win dir since users most familiar with that
* Mobile - Tallscreen so favor vertical

When drawing simply change the list length before newline

Still the issue of sublists:
* Atom spacing maintained
* List spacing maintained

If newspace, how to link them?

The problem is when pointer over NIL, don't know if next key press will append
at that point or append to new list

Or to show it move underneath and make upside down?

Or instead of () -> (NIL)

##############################

To utilize external symbols, only need to manage databases
and then setup classes with relations

1920*1200*4 = 9000 kb = 8.8 MB
100 mb = ~ 10 HD images

How to diff symbols/lists? (nums are atomic)
List is easy
Symbols are based on lists

obj distribution
https://www.mail-archive.com/picolisp@software-lab.de/msg03305.html

################################
################################

cirru editor?

leo editor?

Every particle has the ability to be tagged

"this is a sentence with a " link "in it that has further info"

Particle data:

[.|.]
STR

[.|.] -> [.|.] -> [.|.] ->
STR      LINK     STR

Here, user must break string at desired point to insert link
A function would be best here

Options:
1. Break by new line, goto line
  -> Or use function to go to line and break

We are an OOUI

Computer initially programmed by text/symbols but it has evolved
beyond that - doesn't mean we need to through out text but we
need to incorporate other methods of communication.

So if we could incorporate the features of Emacs but instead of
solely applying that to text, we apply it to any data.

Why emacs fail at discoverability?

Take MS office for example - the ribbon
User can go through all the menus to find what they are looking
for. Sure, it can be a waste of time but its still faster than
trying to figure out a command which means going through the manual
or finding it through google...
If emacs had a default search bar, it would make it so much more
convenient for users

Implications for Particle
* Need an equivalent of menu (menu list) - layout all the bindings
and commands - expose the basic ones
* Need a more explicit search bar (lets call it search list)
  -> A symbol called search-list which has a list user adds to
    ((cmd-1 (result ...))
     (cmd-2 (result ...))
     (cmd-3 (result ...))

Focus on the idea of lists will make it easier for a user to
understand because of the analogy

Emacs difficult because multiple ways to do things and no default
way to do it

Emacs buffer is an interface to the interpreter

lem vs emacs?

THE FUTURE?
WASM -> LLVM IR -> TGT

Reality is just a convenient measure of complexity
-alvy ray smith

===============

(a b NIL)

[] -> [] -> [] -> NIL
a     b     |
            NIL

vs 

(a b (NIL))

[] -> [] -> [] -> NIL
a     b     |
            [] -> NIL
            NIL


If user "enters" NIL (aka empty list), replace it

[] -> [] -> [] -> NIL
a     b     |
            NIL (-> X)

Replace CDR of b - so get previous upon enter
Should use spatial get instead of list traversal

(a b (x))

[] -> [] -> [] -> NIL
a     b     |
            [] -> NIL
            X

The Sad State of Personal Knowledge Bases

So all knowledge can be seen as connected, 
but all knowledge can also be put into hierarchies. 
Concepts and how those concepts are related is something that people come up with, 
rather than being an inherent property of the universe.

The idea of forcing yourself to put knowledge into hierarchies is that it makes your thinking more clear, 
makes it easier to remember where things are, 
and perhaps paradoxically makes it easier to see how things are related. 
(Or at least highlights certain types of relationships 
that are only visible in the context of hierarchies.)

I'll admit it's pretty weird at first to only get one root node, 
I think it took me a couple years to get used to that. 
But once I embraced it the benefits quickly became clear. 


It is not about store and searching information but
having ways to structure and visualize it


Tags speed up searches by avoiding full text

(find-tag these are some words)
(find-tag (these are some words))

OR = find at least one of the tags
AND = find all of the tags
FIL = filter left to right

To automake tags, ignore common words

Build DSL for it

Test DB up to 50 GB

Build different data structures to simulate
YT, IG, FB, BLOGs, TODO LISTS, GITTER/CHAT, etc.

Need to optimize/shortcut string input so users aren't constantly
packing
- auto make strings after a certain length
- if we hide the conses shouldnt be too bad
- also hide the quotes
- start string when typing, end upon mod+Enter or mod+Space
- or time-based, if user stops typing string is automatically made
  - make sense with stop and go thinking


=======================


Store particles in db
Store gpu buffers in db

[DISK/DB] -> [RAM]

Data created by user...need classes for basic types

+Sym - needs a name

                        cell [PARTICLE]
                          |
              +-----------+-----------+
              |           |           |
           Number       Symbol       Pair
                          |
                          |
     +--------+-----------+-----------+
     |        |           |           |
    NIL   Internal    Transient    External
  
Particle
  Atom (Number/Symbol)
  Pair
    len

Length for pair, symbol, number
Default for strings is to pack until user creates non-string
or presses <mod>+Enter
-- easier for users
-- or remove quotes ... or draw lighter
   -- maintain consistency with reader
   
Whhat if uesr wants to tag part of the string?
-- Move pointer and tag
-- Or split it

[.]
("this is an important word that needs to be marked")

[.]
[.]                     [.]    [.]
("this is an important" "word" "that needs to be marked")

Instead of breaking the string apart, the tag simply maintains
a pointer to it with pos in string

This goes into string manipulation...
User can extract the word by breaking the string into words
- using split
Without that, can calulate which char based on distance

chop (by space etc; list uses split)
mark range of list
tag
pack excl tagged

FINAL VERDICT: 
Focus on bigger picture; worry about this later...
For now, we can tag particles aka lisp data.
If user really wanted it, they could refactor into another
item in the list

Question is whether it should be made visible:
("The quick brown fox jumped over the fence")
("The" "quick" "brown" "fox" "jumped" "over" "the" "fence")

Poss draw without quotations or make them very light
Poss indicate with color instead

Spaces would need quotations still

Raw verbatim text search is triky; poss use other methods to
narrow range before performing full text search which would
require combining strings into buffer before actual search

Without the above example, only break apart strings, as needed

Default mode could be to create strings when user presses space
-> PROBLEM, how to create strings with spaces?
   -> Use cmd
   
what if user initiates with quotes? can't close with quote...
must escape it...

================

The Use of Space in Text Editors

================

How to mix layouts?

Layout property belongs to each list:
(+/-|X/Y LEN)

Pos/neg means direction perpendicular

'x

[.|.] CDR
CAR


'y

[.|.] CAR
CDR


Given LEN=2

'x

[.|.] -> [.|.]

CAR      CAR

(cont. from above end)

[.|.] -> [.|.] CDR

CAR      CAR


'y
          (cont. from left bottom)
            
[.|.] CAR  [.|.] CAR

 |          |
[.|.] CAR  [.|.] CAR

           CDR


Layout only applies to top level atoms;
any sublists have their layout defined

When lists are drawn, its bounds are saved
Upon any of its items moving, the bounds are updated


Full X layout with nested lists

A A A .             A A A
      B B .     B B
          C C C
          

So if C gets another item, B.X inc, A.X inc
Subsequent items in B and A must move forward


A A A .           A A A
      B B .   B B
          C C
          C C
          C ...
          
If C is vertical, then parent lists do not need subsequent items moved


Layout Strings

Must specify:
1. Direction of CDR = X or Y
2. Direction of CAR/growth = For X, grow up or down; For Y, grow fwd or back
3. Max length

* When length = 0, #2 negligible
-> This means combine 3 into 2, it's either 0 or +/-#

* Char codes can be used for newline and tab

* Offset codes relative to base
  (NUM AXIS)

Typical let statement:

(let (A B
      C D
      ...)
  E
  F
  G
  ...)

Let has vert orientation with exception - draw first two hor  
List ABCD has -X orientation with length=2
  - Neg bc items grow -Y
  - X bc CDR across
List EFG has -Y orientation with length=0
  - Neg bc items grow -Y
  - Y bc CDR below
  - 0 means single column/row so growth is negligible

Results in:

((-X 1) (-X 2) ^J
 (2 X) (-Y 1))

This means 1st item use 1st
second item use 2nd
^J means move to newline
offset 2 spaces in x direction
3rd and remainder uses 4th


TODO:
1. Draw lists/layout
2. Calculate bounds
  * Use global vars instead of passing between functions
3. Test mixed lists and reflow with random modification


DID WE JUST CREATE A DSL FOR LIST LAYOUT/DRAWING?

Note, changing bidirectional layouts will cause search before AND
after

=====

Each process will store a local cache of a symbol
- Cycle of read, modify, draw, write - repeat
However, all processes will push the generated data to rasterizer

How to draw a list when an item in the middle is modified
-> Must know its index
-> So must traverse list from beginning - find item in list
-> Cannot consistently cache index
-> Can cache provided nothing before it is modified
   at that point, it must be discarded
-> Cache store the last accessed CDR in the main list
   so if user added items multiple times in a row, it can
   reuse it; afterwards, empty it


UNDERSTANDING CODE IS HARDER THAN EXPLORING IT

===============================================

How To Handle Mixed Layouts

Check if prev (car/cdr) is opposite layout

For example if default is y but prev is x
must use final y from prev

  #{
  
    [] -> [] -> []
    |     1     2
    |
    [] -> 3
    |
    [] -> 4


    [] -> [] -> 1
    |     |
    |     [] -> 2
    |
    [] -> 3
    |
    [] -> 4


    [] -> [] -> []
    |     1     2
    |
    [] -> []
    |     |
    1     2
    
    3 variations with spacing - either top/bottom is closer to base
    or equidistant
    
  }#

===================

We can define symbols as "tags for data" 
(objs are symbols so symbols are objs)

Conventional programs focus on the data and attaching tags

What if we focus on tags and then attaching data to it?

A tag viewport can be positioned L/R or T/B, since we use a tile layout
* Really just a generic viewport, that the user can have a camera follow
a list, either adjust zoom+pan to fit entire object or only part of it
etc.

If everything is a symbol then it can be tagged!

There exists other objects like lists and numbers,
and of course, other symbols like strings
so how do those get tagged since they are no symbols?

-> Use a symbol to store the object, and then tag it by adding to its
tg list

In other words, create a Particle that stores the object (its value)
and add to its tg list

In this case an external object is used
which has a unique numeric id
based on its position in the file/block/offset

It can also be referenced through the tags that it has
(this is the expected way to find it)

Since everything the user sees is a particle, it can be tagged
-> EVERYTHING IS TAGGABLE...


However, symbols can contain a list etc. - compound structures
So in order to tag individual parts in the compound structures,
they must be broken out somehow

For example, a symbol contains a list of words - no, each word in the list
is actually a particle so they can be individually tagged.
However, if a part of a string is to be tagged it must be broken out

IDEA!

Given:

("The quick brown fox jumped over the fence")

Break out words in a sublist:

( ("The quick brown fox jumped over the fence")
  "fox" [tag this]
)

However, what if the user edits the string?
-> Then user must edit list
-> Makes sense since it is not a valid tag...
-> This can be made automatic so that it is cleared
when the string is edited
-> User might want to keep it so what is the default?
-> KISS and Principle of Least Astonishment
-> Best way would be if the word is removed from the string,
the tag should be removed also

( ("The slow grey elephant jumped over the fence")
  [nothing here anymore]
)

At this point, this list of tags should become a property of the particle
or more specifically for a string/symbol particle

For the tagged word in the property list, it would need a property to store
addtl info (instead of a string symbol, make it a particle or subclass of it)
such as pos so that we can tell if it has been modified

===========

PicoLisp has a spatial structure but only works in +X and +Y...
We can create for db files, depending on the quadrant the object lies in

===========

How To Link Symbols?

Create Link object, which contains the external/internal symbol

WHAT IS OUR MVP

===============

How To Create A Tree Structure

  ("I"
    ("I.A")
    ("I.B"
      ("I.B.1"
       "I.B.2"
       "I.B.3"))
    ("I.C"
      ("I.C.1"
       "I.C.2"
       "I.C.3")))

I .   .              .
  IA  IB .           IC .
         IB1 IB2 IB3    IC1 IC2 IC3

* Add "I"
* Add NIL
* Enter list
* Add "I.A"
* Exit list
* Add NIL
* Enter list
...
* Exit list
* Add NIL
* Enter list
* Exit list


MIXED ARBITRARY:

. . . A
A A . A
    . A
    . . . NIL
    A A A

Modifying mid-list would result in relayout


============================================

A list/pair would contain vol for all items in list until NIL
A num/sym would contain vol for direct CAR and CDR

Calc vol for a pair = vol cell + vol CAR + vol CDR + spacing

[.] CAR
    asdf
    asdf
    asdf

[.] CAR
    adsf
    adsf
    adsf
    
[.] CAR
    asdf
    adsf
    asdf


      (NIL)
[.] - [.] - NIL
      NIL

      ("A")
[.] - [.] - NIL
      
      
      [.] 
      "A"


((CAR))

[.] - CDR
CAR
 |
[.] - CDR
CAR

When lay=x and enter-list, switch to modify car; vice versa, for exit list
- Do this once, then return to cdr

When lay=y and enter-list, switch to modify cdr; vice versa, for exit list

(CAR CAR)

[.] - CAR
CDR
 |
[.] - CAR
CDR


Pressing ascii key results in replacing CDR
except when enter-list is called 
which results in replacing the CAR
then returns to normal
