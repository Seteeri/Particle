################################################################################


#{
(mc dst src sz off)
# src = NIL -> read bytes after msg
# dst = NIL -> send back on socket
# sz  = NIL -> read all
}#

(dm handle-memcpy> (Sock Data Src)
  # Return how much data read from sock

  #(mc Dst Src Sz) + data
  (let (Dst  (get Data 2)
        Name-Src  (get Data 3)
        Sz   (get Data 4)
        Off  (get Data 5))
    
    (cond ((and Dst Src) # Write bytes to ..., recv from socket
           ((: fn-mc-wr) Dst Src Sock Sz Off)
           Sz)

          ((and (not Dst) Src) # Read bytes from ..., send on socket
           ((: fn-mc-rd) Name-Src Sock Sz Off)
           0)
           
          #{ 
          ((and Dst Src)
           (prinl (usec) " | handle-memcpy | Ptr to ptr memcpy not implemented!")
           (quit "Quiting..."))
          }#
          
          (T
           (prinl (usec) " | handle-memcpy | Invalid Dst Src parameters!")
           (quit "Quiting...")))))
  
  
################################################################################

# Ctrl sends these msgs to workers which execute
# Higher level functions

(dm update-pvm> ()
  (write-pvm> This 
              (read-pvm> This (get-fd> This "MODEL"))
              (get-fd> This "RENDER")))
       
       
(dm update-vert> (Cnt)
  (write-vert> This 
               (read-vert> This (get-fd> This "MODEL") Cnt)
               Cnt
               (get-fd> This "RENDER")))
               



# Workers call these

# Projview/Vert
#(de cpy-to-lisp> () (deserialize))
#(de cpy-to-ptr> () (serialize))
#(de fmt-msg-send/recv> ())

# IPC
# send/recv-obj

# For both
#(de cpy-ptr-to-ptr  () (memcpy))

# To decide which argument should have the method - depends on which will is
# the most specific
# Under IPC, would require explicit control flow statements
# Under PVM/VERT, would require least explicit control flow statements and
# easiest to read/understand and least amount of duplication

# Projview
  
(dm cpy-to-ptr> (Ptr)
  # Obj
  
  # Serialize to struct
  (let Data (serialize> This)
    (struct Ptr 'N Data)
    128)) # hardcoded or get from serialize somehow


(dm fmt-msg-send> (...)
  # Obj
  
  # Fmt as needed
  "(mc NIL projview 128 0)")
  

(dm send-obj> (Sock Obj)
  # IPC

  # Better to write all strings/bytes to buf-wr, then send in one go
  
  ########################
  # WORKER -> RENDER/MODEL
  (send-msg> This 
             (fmt-msg-send> Obj ...)
             Sock)


  # RENDER response: ptr -> ptr (mc)
  # MODEL response: ptr -> lisp

  
  # Cpy obj to sock ptr
  (cpy-to-ptr> Obj 
               (: buf-wr))

  # Send all
  (send-bytes> This
               Sock
               T # buf-wr
               128))


############


(dm cpy-to-lisp> ()
  # Obj
  T)


(dm fmt-msg-recv> (...)
  # Obj
  
  # Fmt as needed
  "(mc NIL projview 128 0)")
  

(dm recv-obj> (Obj)
  # IPC
  # Either pass in object or instance new one
  
  #################
  # WORKER -> MODEL
  (send-msg> This 
             (fmt-msg-recv> Obj ...)
             Sock)
  
             
  # RENDER response: ptr -> ptr (mc)
  # MODEL response: lisp -> ptr
  
  
  # Recv all
  (recv-bytes> This
               Sock # buf-rd
               T
               128) # (get Obj 'sz-ptr)
  
  # Rename to paste
  (cpy-to-lisp> Obj
                (: buf-rd)))


################################################################################
# Vert


(dm read-vert> (Sock Cnt)

  # Get raw bytes -> Reconstruct object
  (send-msg> This (pack "(mc NIL nodes 208 " (* (- Cnt 1) 208) ")") Sock)
  
  (let Bytes-Recv (recv-bytes> This Sock T 208)
  
    (if (= Bytes-Recv 208)
      (struct (: buf-rd) '((-1.0 . 16) (-1.0 . 16) (-1.0 . 16) (I . 4)))
      (prinl (usec) " | read-vert | Bytes-Recv=" Bytes-Recv " errno=" (errno)))))


(dm write-vert> (Vert Cnt Sock)

  # Serialize pvm
  (send-msg> This (pack "(mc nodes NIL 208 " (* (- Cnt 1) 208) ")") Sock)
  
  (let P (: buf-wr)
  
    (struct P           'N (cons -1.0 (get Vert 1)))
    (struct (inc 'P 64) 'N (cons -1.0 (get Vert 2)))
    (struct (inc 'P 64) 'N (cons -1.0 (get Vert 3)))
    (struct (inc 'P 64) 'N (cons (get (get Vert 4) 1) 4)
                           (cons (get (get Vert 4) 2) 4)
                           (cons (get (get Vert 4) 3) 4)
                           (cons (get (get Vert 4) 4) 4)))
  (send-bytes> This
               Sock
               T
               208))
               

################################################################################

# Serialize/Deserialize
# Marshal/Unmarshal
# Assemble/Disassemble
# Reconstruct/Deconstruct

# ptr/sock and lisp differ by types: pvm, nodes
# so must define these 4 functions per type/mem

# Input/Ctrl send only messages/strings
# Workers send objects to/from Model,Render

#(de cpy-ptr-to-lisp () (deserialize))
#(de cpy-lisp-to-ptr () (serialize))
#(de cpy-ptr-to-ptr  () (memcpy))

#{

(de write-dst-2 (Dst Src Sock Sz Off)

  # Model  writes to lisp | from sock ptr
  # Render writes to ptr  | from sock ptr (with memcpy)

  #(ipc~recv-bytes> *ipc Sock NIL Sz)
  
  (cond ((= Dst "projview")
         (let (Ptr-Gl  (get (get '*buffer-objects 'projview) 'gl~ptr)
               Ptr-Buf Src)
           (memcpy Ptr-Gl Ptr-Buf Sz)))
   
        ((= Dst "nodes")        
         (let (Ptr-Gl  (+ (get (get '*buffer-objects 'nodes) 'gl~ptr) Off)
               Ptr-Buf Src)
           (memcpy Ptr-Gl Ptr-Buf 208)))))


(de read-src-2 (Dst Src Sock Sz Off)

  # Model  reads from lisp | to sock
  # Render reads from ptr  | to sock

  (cond ((= Src "projview")
         (with *projview
          
           # Abstract out
           (serialize-mat-to-ptr (: mat-proj) (: ptr))
           (serialize-mat-to-ptr (: mat-view) (+ (: ptr) 64))
           
           (ipc~send-bytes> *ipc
                            Sock
                            (: ptr)
                            128)))
   
        ((= Src "nodes")
         (ipc~send-bytes> *ipc
                          Sock
           
                          # Abstract out               
                          (serialize-to-ptr> (get *verts (+ (/ Off 208) 1)))
                          
                          208))))
                          
}#



(dm flush-msgs> (Sock Fn)
  #{
  * Recv length as int, then recv payload
  * Do until length of initial bytes
  }#

  (let (Ptr (: buf-rd)
        Bytes-Proc 0
        Bytes-Read-Len (recv-bytes> This Sock Ptr T))

     (prinl "Bytes-Read-Len: " Bytes-Read-Len)

     #{
     # Not enough bytes for a single msg, raise error
     (when (< Bytes-Read-Len 4)
        (prinl (usec) " | flush-msgs> | (= (< Bytes-Read-Len 4) T) -> Implement continuations!")
        (quit "Quiting..."))
     }#
     
     # Otherwise loop until no msgs left
     (while (< Bytes-Proc Bytes-Read-Len)
     
       #(prinl "Bytes-Proc: " Bytes-Proc)

       # Get length
       (let Length (car (struct Ptr '(I)))
       
          #(prinl "Length: " Length " [" Bytes-Read-Len "]")
          #(println (struct Ptr '(B . 32)))

          (inc 'Bytes-Proc 4)
          (inc 'Ptr 4)

          (prinl "Unpacked: " (pack (struct Ptr (cons 'C Length))))
          
          # Returns any bytes read from sock
          # Function will try to read from Ptr instead of Offset...
          # 1. Pass Ptr payload here - must modify other fns
          # 2. Store Offset in ipc
          (let Read-Payload (Fn Sock (pack (struct Ptr (cons 'C Length))) Ptr)
            (inc 'Bytes-Proc (+ Length Read-Payload))
            (inc 'Ptr (+ Length Read-Payload)))
          (prinl "Bytes-Rem: " (- Bytes-Read-Len Bytes-Proc))))
              
      (println "DONE")))
      

################################################################################


(de read-pvm (Sock)

  (send-msg> This 
             "(mc NIL projview 128 0)" 
             Sock)

  (let Bytes-Recv (recv-bytes> This Sock T 128)

    (if (= Bytes-Recv 128)
      (struct (: buf-rd) '(-1.0 . 32)) # Use structure
      (prinl (usec) " | read-pvm | Bytes-Recv=" Bytes-Recv " errno=" (errno)))))


(de write-pvm (Pvm Sock)

  # Serialize pvm
  (send-msg> This 
             "(mc projview NIL 128 0)" 
             Sock)

  (struct (: buf-wr) 'N (cons -1.0 Pvm))

  #(println "write-pvm" (struct (: buf-wr) '(B . 128)))

  (send-bytes> This
               Sock
               T
               128))


(de read-vert (Sock Cnt)

  (send-msg> This
             (pack "(mc NIL nodes 208 " (* (- Cnt 1) 208) ")") 
             Sock)

  (let Bytes-Recv (recv-bytes> This Sock T 208)

    (if (= Bytes-Recv 208)
      (struct (: buf-rd) '((-1.0 . 16) (-1.0 . 16) (-1.0 . 16) (I . 4)))
      (prinl (usec) " | read-vert | Bytes-Recv=" Bytes-Recv " errno=" (errno)))))


(de write-vert (Vert Cnt Sock)

  # Serialize pvm
  (send-msg> This
             (pack "(mc nodes NIL 208 " (* (- Cnt 1) 208) ")") 
             Sock)

  (let P (: buf-wr)

    (struct P           'N (cons -1.0 (get Vert 1)))
    (struct (inc 'P 64) 'N (cons -1.0 (get Vert 2)))
    (struct (inc 'P 64) 'N (cons -1.0 (get Vert 3)))
    (struct (inc 'P 64) 'N (cons (get (get Vert 4) 1) 4)
                           (cons (get (get Vert 4) 2) 4)
                           (cons (get (get Vert 4) 3) 4)
                           (cons (get (get Vert 4) 4) 4)))
  (send-bytes> This
               Sock
               T
               208))
               
