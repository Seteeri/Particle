60 bits = 1 152 921 504 606 846 976

Systemd has effectively rewritten the Linux userland, which depending on your
interpretation, now provides a unified userland, which may be deemed most
appropriate for servers and sysadmins. However, I believe for the desktop user
and developers, it does not provide an appropriate interface, as it still relies
on C and shell scripts through ini files, which is essentially a scripting
analogue to C and a way to manage C processes/programs.

VENN DIAGRAM CIRCLES

* BSD
* Blender
* Emacs
* Evernote
* Elementary OS
* Arcane
* Interlisp-D

################################################################################

Traditionally computers have worked by having different applications and
UIs working on both different and similar data with overlapping
operations and functionality. For example, a word processor might include
some image editing operations, and an image editor might provide the
ability to rasterize text.

The idea of Protoform is to invert that model so users have a consistent
interface with less redundancy which is faster to learn. Data today is
not simply numbers and text but much more, and users need an interface
that can cut across all domains.

################################################################################

For images, load entire image as a texture and then break into tiles
as user works on it, 2,4,8,16,32,64 etc

Make smart process - release tile if user moves to another tile
after a certain amount of time or learn users behavior to calculate the
threshold

################################################################################

text   -> raster (texture)
raster -> text (OCR)

text     -> waveform (text-to-speech)
waveform -> text (voice recognition)

raster   -> waveform (texture)
waveform -> raster (texture)

waveform/spectrogram/bitmap

UNREAL BLUEPRINTS
- Cannot create new nodes with nodes - but we can!

https://news.ycombinator.com/item?id=14482988

################################################################################

Forward... -> Tiled -> Clustered -> Volumetric

See Volume Tiled Forward Shading is based on Tiled and Clustered Forward Shading described by Ola Olsson et. al

################################################################################

https://stackoverflow.com/questions/24839857/wireframe-shader-issue-with-barycentric-coordinates-when-using-shared-vertices
https://catlikecoding.com/unity/tutorials/advanced-rendering/flat-and-wireframe-shading
https://www.reddit.com/r/opengl/comments/3yrv79/simplistic_texture_less_tronlike_3d_with_opengl/

################################################################################

How to Design Help System

Use lisp describe method as starting point

User sees an object and wants to do something with it but does not know

Object -> What Function? -> Desired Output

Type help after it and it will print info for that node

- Use a game to teach commands? Like ad destroyer...user has to destroy
nodes as they popup...use augmented reality like pokemon
 - start with basic commands like add/delete nodes, linking nodes, eval,
 swapping nodes, toggling ids

 - Use it to introduce concepts for widgets/GUI so users understand
 how they work - or should animations

 What are the most addictive games?
 Fruit ninja, gem stone game, pokemon go?

 - People like mice because it has two buttons - easy to use and understand
   - They move/hover/point at an object -> press a button -> something happens
 - Mouse's buttons (functions) act on widgets which are generally
 standardized across programs
 - Essentially we want something like that but more powerful
 - Instead of the mouse, we use basic keyboard functions...

 How to combine mouse on one hand, and keyboard on the other?
 Mouse is continous whereas keyboard is discrete
 Keyboard can move 1 step whereas mouse can use physical properties
 like velocity/acceleration

 22. Should pointer target be predecessor or successor?
    - Successor makes sense since pointer is like an arrow


################################################################################

Never liked the idea of the cursor being inbetween chars...
Ambiguous as to whether the previous or next is being selected
Or not? Since list points to right side typically...

CLI: Type command -> Enter (no shortcuts)
Emacs: Key chords/bindings + modes [MAX KEYBINDINGS/MODESish]
Archy: Quasimode + type command [MIN KEYBINDINGS/MIN MODES]

US: Type command -> Eval

https://academia.stackexchange.com/questions/109/is-there-any-efficient-non-linear-note-taking-software
                                  *
https://softwareengineering.stackexchange.com/questions/224146/how-has-an-increase-in-the-complexity-of-systems-affected-successive-generations/224152

Moreover, let's not forget what we're actually trying to optimize for, which is
value produced for a given cost. Programmers are way more expensive than
machines. Anything we do that makes programmers produce working, correct,
robust, fully-featured programs faster and cheaper leads to the creation of
more value in the world.

################################################################################

https://news.ycombinator.com/item?id=15466124

No.

I expect this will be a fairly controversial comment, so I want to preface this by saying that I'm a big Lisp fan (just look at my handle). Lisp is my favorite programming language. I've been using it for nearly forty years. My first Lisp was P-Lisp on an Apple II in 1980. And I worked on Symbolics Lisp machines in the 1990s. They were very cool, but there's a reason they failed: general-purpose computing is infrastructure, and the economics of infrastructure are such that having a single standard is the most economical solution, even if that standard is sub-optimal. For better or worse, the standard for general-purpose computing is the C machine.

Because it's general-purpose you certainly can run Lisp on a C machine (just as you could run C on a Lisp machine). You can even do this at the system level. But Lisp will always be at a disadvantage because the hardware is optimized for C. Because of this, C will always win at the system level because at that level performance matters.

But that in and of itself is not the determining factor. The determining factor is the infrastructure that has grown up around the C machine in the last few decades. There is an enormous amount of work that has gone into building compilers, network stacks, data interchange formats, libraries, etc. etc. and they are all optimized for C. For Lisp to be competitive at the system level, nearly all of this infrastructure would have to be re-created, and that is not going to happen. Even with the enormous productivity advantages that Lisp has over C (and they really are enormous) this is not enough to overcome the economic advantages that C has by virtue of being the entrenched standard.

The way Lisp can still win in today's world is not by trying to replace C on the system level, but by "embracing and extending" C at the application level. I use Clozure Common Lisp. It has an Objective-C bridge, so I can call ObjC functions as if they were Lisp functions. There is no reason for me to know or care that these functions are actually written in C (except insofar as I have to be a little bit careful about memory management when I call C functions from Lisp) and so using Lisp in this way still gives me a huge lever that is economically viable even in today's world. I have web servers in production running in CCL on Linux, and it's a huge win. I can spin up a new web app on AWS in just a few minutes from a standing start. It's a Lisp machine, but at the application level, not the system level. My kernel (Linux) and web front end (nginx) are written in C, but that doesn't impact me at all because they are written by someone else. I just treat them as black boxes.

I don't want to denigrate ChrysaLisp in any way. It's tremendously cool. But cool is not enough to win in the real world.

[UPDATE] ChrysaLisp is actually doing the Right Thing with respect to its GUI by
 using a C-library (SDL). But it's trying to re-invent the compiler wheel (and
 the language design wheel) so that it can run on bare metal and "grow up to be
 a real Lisp machine" some day, and I think that aspect of the project is a
 fool's errand. There are already many Lisps that can run on bare metal (ECL was
  specifically designed for that). None of them have succeeding in displacing C,
  and I believe none ever will because the economic hurdles are insurmountable.

################################################################################

(defun read-64 (buf)
  (let ((u 0))
    (setf (ldb (byte 8 56) u) (aref buf 7))
    (setf (ldb (byte 8 48) u) (aref buf 6))
    (setf (ldb (byte 8 40) u) (aref buf 5))
    (setf (ldb (byte 8 32) u) (aref buf 4))
    (setf (ldb (byte 8 24) u) (aref buf 3))
    (setf (ldb (byte 8 16) u) (aref buf 2))
    (setf (ldb (byte 8 8) u) (aref buf 1))
    (setf (ldb (byte 8 0) u) (aref buf 0))
    u))

(defun read-32 (buf)
   (let ((u 0))
    (setf (ldb (byte 8 24) u) (aref buf 3))
    (setf (ldb (byte 8 16) u) (aref buf 2))
    (setf (ldb (byte 8 8) u) (aref buf 1))
    (setf (ldb (byte 8 0) u) (aref buf 0))
    u))

(defun read-16 (buf)
  (let ((u 0))
    (setf (ldb (byte 8 8) u) (aref buf 1))
    (setf (ldb (byte 8 0) u) (aref buf 0))
    u))

################################################################################

http://www.cs.cmu.edu/afs/cs/academic/class/15210-f15/www/tapp.html#ch:multithreading

Keys to Achieving Parallelism

1. DAG
2. Atomics - minimize usage of locks

Should a task that readds itself create a new task instance or reuse
existing?

https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands

From
a consumer perspective, the lower abstractions are becoming virtualized
at the convenience of the user, i.e. web browser becoming a platform.
However, the increase in data breaches and security issues have not
completely eroded the OS a key factor.

https://www.reddit.com/r/lisp/comments/9q68y8/has_the_gnu_coreutils_ever_been_implemented_in/

https://www.reddit.com/r/lisp/comments/1fj0qf/lisp_vs_haskell/

https://github.com/BusFactor1Inc/sxc

https://news.ycombinator.com/item?id=13199610

https://www.cliki.net/cl-emacs

Difference between having source code and then eval'ing it like in EMACS
versus having those live data objects accessible in the program like in
Protoform.

https://nullprogram.com/blog/2014/06/29/

Organize functions based on I/O
node -> node
text -> node

https://mattdesl.svbtle.com/drawing-lines-is-hard

http://www.osenkov.com/diplom/contents/1/4/

https://github.com/sile/taomp-sbcl

http://etodd.io/2016/01/12/poor-mans-threading-architecture/

if our engine is a particle system, how to do lighting?

must move as much code to the compute shader as possible

https://www.pvk.ca/Blog/2013/04/13/starting-to-hack-on-sbcl/

http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html

epoch
bbinit

shell = scripting language for C (processes)

########################################################################

Separate parts become a whole when it is more efficient to do so or
when the interaction of those separate parts becomes more complex than
those parts as a whole.

########################################################################

SASOS

in single address space, the language is unified and thus passing data
is unified. instead of different processes with different formats,
functions pass objects around (ostensibly passing symbols).

unix:
shell process executes C process(es) which communicate through pipes which
are implemented like a file underneath

lisp:
lisp image contains objects which communicate through functions

What we want to do is take that pipeline message passing model and build
on it by using a general purpose language to facilitate it (or build DSL)

We can go further and use DAGs to describe a pipeline that can allow
for parallelization. in this case, we hook objects including fn's
(since fn's are 1st class objects in lisp)

Imagine each C process managing memory along with interpreted languages
with their own GCs versus a single GC managing all the memory and objects.

That includes multiple levels of redundancy increasing complexity and
chances of bugs.

Does this outweigh the disadvantage of a single point of failure?

It is easier to make a single system more stable than multiple systems

However, this single system must be simpler thus easier to understand
and modify than multiple systems, which in the case of lisp vs c, yes

http://wiki.c2.com/?SingleAddressSpaceOperatingSystem

https://www.usenix.org/legacy/event/usenix99/full_papers/deller/deller.pdf

https://news.ycombinator.com/item?id=11187072
http://www.lighterra.com/papers/modernmicroprocessors/

systemd issue is cohesion and coupling - high cohesion and high coupling
high coupling being bad since indicative of high complexitty

Linux kernel-userspace: low cohesion, low coupling

area = group of nodes or leaf?
coupling is like number of edges between two given areas
cohesion is like number of nodes in a given area

the other issue is systemd is more dynamic - able to respond to events
better like hot-plugging...same is becoming more desirable in code...lisp?

GC STILL AN ISSUE...moves nodes to different memory for static objects..weak refs?

ZERO FRAGMENTATION HEAP -> LINEAR HEAP
https://library.softwareverify.com/memory-fragmentation-your-worst-nightmare/

################################################################################

Expand heap = (gc N>0)
Shrink heap = (gc 0)
Heap total size = (heap)
Heap used size = (heap T)
Avail ptr = Cons + adr

Heap address (start) = ?
Avail = ?

Start of frame, cons, store address
- To find avail, could search memory for pointer
End of frame, modify avail to original address

################################################################################

https://emersion.fr/blog/2018/wayland-rendering-loop/

convetionnal: hetero ui - hetero data (overlap)
flip:         homo   ui - hetero data (data/file types)

must provide way to work with all data - open source to start with like OpenDocument

In LISP all data is made of cons cells
In Protoform all trees(UI) are made of nodes
Nodes = cons cells

Buttons are a single node
"Clicking" (state change) is triggered by link/eval (like moving and clicking)
  or poss: pre-link+eval = read->eval, post-link+eval = quote->eval
  this would be like moving over "presses" button

  [code = str; all just bytes->bits->binary in the end ;)]

  general tree -> binary tree (diff data encodings, gen tree lowered to cons/binary tree)
  code         -> data        (diff data encodings, str is lowered to cons/bytes/bits/binary)

  read  = code -> data
  print = data -> code

  quote = data -> code (lets data be code)
  eval  = code -> data (code is what we understand; data is what computer understands)

idea is ops performed on gen tree can afterwards still convert back to cons
str is understood by humans and cons/bytes/bits/binary is understood by machines
- translate both ways is the key to understanding and efficiency/productivity
gen tree is understood by humans and binary tree is understood by lisp interpreter/eval
ui/nodes are code and data
nodes can be transformed to data so that node represents its value (unless quoted)

(setq node 0)

(when <node/data> (exit)) ; triangles = data
-> 0 (numeral)

vs

(when (node/code) (exit)) ; squares = code
-> node (symbol/string)

print = tri -> sq
read = sq -> tri

so node can represent both code and data and user can apply transformers

Link multiple times which cannot be done in binary tree
node=T
-> when
-> if
-> ...

In lisp code, this would just be a symbol refernced by all

: (scl 4)
-> 4

: (setq P (native "@" "malloc" 'N 16))
-> 10851136

: P
-> 10851136

: (struct P 'N (1.0 0.11 0.22))
-> 10851136

: (struct P (1.0 . 2))
-> (1100 2200)


https://stackoverflow.com/questions/17717600/confusion-between-c-and-opengl-matrix-order-row-major-vs-column-major

9.005 Are OpenGL matrices column-major or row-major?

For programming purposes, OpenGL matrices are 16-value arrays with base vectors laid out contiguously in memory. The translation components occupy the 13th, 14th, and 15th elements of the 16-element matrix, where indices are numbered from 1 to 16 as described in section 2.11.2 of the OpenGL 2.1 Specification.

Column-major versus row-major is purely a notational convention. Note that post-multiplying with column-major matrices produces the same result as pre-multiplying with row-major matrices. The OpenGL Specification and the OpenGL Reference Manual both use column-major notation. You can use any notation, as long as it's clearly stated.

Sadly, the use of column-major format in the spec and blue book has resulted in endless confusion in the OpenGL programming community. Column-major notation suggests that matrices are not laid out in memory as a programmer would expect.



################################################################################

Each vertex has either a texture or a pixel (no texture)

################################################################################


: "X"
-> "X"
:
: (struct (+ (>> -4 (adr '"X")) 0) '(B . 16))
-> (130 5 0 0 0 0 0 0 40 203 209 14 180 127 0 0)

-So CAR and CDR are two different pointers
 ...which is probably two instances of the name then...

 Trans symbol
 - name stored directly in car/left
 - right changes with value, however, it is not nil
 - initially it is not the same as name
   -> name may be contained in another cell

:
: (struct (- (>> -4 (adr "X")) 0) '(B . 16))
-> (130 5 0 0 0 0 0 0 216 221 163 76 236 127 0 0)
:
: (struct 140652874816984 '(B . 16))
-> (216 221 163 76 236 127 0 0 216 221 163 76 236 127 0 0)
:


: (struct (- (>> -4 (adr (box))) 0) '(B . 16))
-> (2 0 0 0 0 0 0 0 72 215 66 0 0 0 0 0)
: (struct (- (>> -4 (adr (box 1))) 0) '(B . 16))
-> (2 0 0 0 0 0 0 0 18 0 0 0 0 0 0 0)
: (struct (- (>> -4 (adr (box 0))) 0) '(B . 16))
-> (2 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0)

Anon Symbol:
CAR:  0
CDR: NIL

Transient Symbol:
CAR: name (if name > 7 characters, then ptr to cons cell)
CDR: pointer to CDR of itself (points to symbol)

So CDR points to a cell which points to itself

[name|ptrVAL] ->

How to represent numbers...


ASCII = Character
Number = Character

Alt+ASCII = Type Num
Alt+Number = Type Num

Shift+Enter/Tab = Read
Ctrl+Enter/Tab = Eval

################################################################################


https://news.ycombinator.com/item?id=9981874

https://www.bfilipek.com/2015/01/persistent-mapped-buffers-benchmark.html

https://stackoverflow.com/questions/2963898/faster-alternative-to-memcpy

################################################################################

#{
https://gavv.github.io/articles/unix-socket-reuse/

A socket file is created by bind(2) call.
If the file already exists, EADDRINUSE is returned.

Unlike Internet sockets (AF_INET), Unix domain sockets (AF_UNIX) doesn’t have
SO_REUSEADDR, at least on Linux and BSD. The only way to reuse a socket file
is to remove it with unlink().

There are two bad approaches to deal with this problem:

#1

We could call unlink() just before bind().

The problem is that if we run two instances of our process, the second one will silently remove socket used by the first one, instead of reporting a failure.

Also, there is a race here since the socket can be created by another process between unlink() and bind().

We could call unlink() when the process exits instead.

The problem is that if our process crashes, unlink() will not be called and we’ll have a dangling socket.

#2

Using a lock file

One option is to use a lock file in addition to the socket file.

We’ll use a separate lock file and never call unlink() on it. When a process is going to bind a socket, it first tries to acquire a lock:

If the lock can’t be acquired, it means that another process is holding the lock now, because kernel guarantees that the lock is released if owner process exits or crashes.

If the lock is successfully acquired, we can safely unlink() the socket, because we’re the only owner and no race may occur.

#3
Using abstract namespace sockets

Another option is to use Linux-specific abstract namespace sockets.

To create an abstract namespace socket, set the first byte in the sun_path field of the sockaddr_un to \0. See unix(7). This socket will not be mapped to the filesystem, so it’s not possible to use filesystem permissions or remove it with unlink().

The advantage is that such a socket is automatically removed when the process exits, so there is no problem with socket reusing.

}#


################################################################################

https://datenwolf.net/bl20110930-0001/

My dream graphics system was completely abstract. Creating a window didn't involve selecting visual formats, framebuffer configurations. It was just "a window". Only when actual content is involved I want to tell the rendering subsystem, which color space I use. Ideally all applications worked in a contact color space (e.g. CIE XYZ or Lab), but sending images in some arbitrary color space, together with color profile information. Fonts/Glyphs would be rendered by some layer close to the hardware, to carefully adjust the rasterizing to the output devices properties. And last but not least the whole system should be distributed. Being able to "push" some window from one machine's display, to another machine's (and this action triggering a process migration) would be pinnacle. Imagine you begin writing an email on your smartphone, but you realize you'd prefer using a "usable" keyboard. Instead of saving a draft, closing the mail editor on the phone, transferring the draft to the PC, opening it, editing it there. Imaging you'd simply hold your smartphone besides your PC's monitor a NFC (near field communication) system in phone and monitor detects the relative position, and flick the email editor over to the PC allowing you to continue your edit there. Now imagine that this happens absolutely transparent to the programs involved, that this is something managed by the operating system.

Wayland/X11 - uses window buffer/handles
Emacs - uses text buffer

Particle - uses cons cell (buffer)

http://blog.rongarret.info/2015/05/why-lisp.html
http://blog.rongarret.info/2006/10/top-ten-geek-business-myths.html

Every atom generated is a vertex and lists are represented by edges.
-> For strings, need to traverse name cell
-> For symbols, need to traverse property list and name
-> For numbers, traverse for bignums

http://xahlee.info/UnixResource_dir/writ/lisp_problems.html

Confusing
Lisp's irregular syntax are practically confusing. For example, the difference between (list 1 2 3), '(1 2 3), (quote (1 2 3)) is a frequently asked question. The use of ` , ,@ are esoteric. If all these semantics use the regular syntactical form (f args), then much confusion will be reduced and people will understand and use these features better. For example:

(a . b) ; bad

(. a b) ; good
'(1 2 3) ; bad

(' 1 2 3) ; good
; or
(list-literal 1 2 3) ; good
(setq myListXY `(,@ myListX ,@ myListY)) ; bad

(setq myListXY (` (,@ myListX) (,@ myListY))) ; good
; or
(setq myListXY (eval-parts (splice myListX) (splice myListY))) ; good


Deep Nesting is Rare
The lisp's cons, as a underlying primitive that builds lists, even though a bit cumbersome, but works just fine when data structure used is simple. Even today, with all the Perl, Python, PHP, JavaScript etc langs that deal with lists, vast majority of list usage is just simple flat list, sometimes 2 level of nesting (list of list, list of hash, hash of list). 3 levels of nesting is seldom used, unless it is 3D matrices used mostly in computer graphics or linear algebra applications. Greater than 3 level is rarely seen. Systematic manipulation and exploitation of nested list, such as mapping to leafs, to particular level, transposition by permutation on level, or list structure pattern matching in today's functional langs, etc is hardly ever to be seen. (These are common idioms in so-called array languages. For example, APL, MATLAB, Mathematica.)

So, in general, when you just deal with simple lists, the cumbersomeness of using {cons, car, cdr, caardr, …} for list doesn't really surface. Further, the cons is fundamentally rooted in the language. It's not something that can be easily changed except creating a new language. When there is a specific need in a application, there is a haphazard collection of functions that deal with lists at a higher level.

KIND OF LIKE POINTERS, EH?

=======================

STRING/SYM FUNCTIONALITY

Primitives:
* Create strings: ASCII keys
* Join/link strings: pack, glue, make/link (better for lists)

* Destroy strings: Backspace/Delete
  * Backspace removes object back of ptr
  * Delete removes object front of ptr
* Split strings:

* Format -> Str : Num
* Intern -> Str/T-Sym, : I-Sym
* Name   -> I-Sym : Str/T-Sym

* Sym - takes printed rep of object and turns into I-Sym; reverse of any
* Str - build string from list

STR CMD (ASCII KEY)
* If ptr=NIL: create free tsym/atom - all nodes already exist so they will not be GC
* If ptr=CAR: replace str; move ptr?
* If ptr=CDR: append str; move ptr to next CDR

# When rendered, draw reverse?

("a")
  |
  *

("b" "a")
  |
  *

("c" "b" "a")
  |
  *

# User presses shortcut to pack/glue -> use list as argument to pack - new list produced
* Three eval methods:
  Shift: Save both (def) - ignore NIL return?

Pack:
-> ("cba")

Glue-P: car used as glue, cdr as list
-> ("bca")

# User moves pointer back to original list, continues typing (or user goes to new list)

("f" "e" "d" "c" "b" a")

# Pack again

("fedcba") or ("fed" "cba")

First is expected behavior so how to create the second result?
-> Create new list by detaching pointer or command
-> Type chars, pack
-> Join lists

("cba")

("fed")

Also can do

(make (link ("cba"))
      (link ("fed"))

##################

LIST FUNCTIONALITY

Primitives:
* Create list
* Destroy list
* Join/link lists

* Free = master list or timeline

LIST CMD
* To create new list, Ctrl/Alt+Char? -> Holding ctrl while typing chars = nested lists
  (a (b (c)))
  Or alternating:
  (a (b c (d e (f))))
  * Alternative is to explicitly create a list each time which is clumsier:
    -> Ctrl+L, A, Ctr+L, B, Ctrl+L, C, ...
* Need command to destroy current list and move to top list, to reverse previous example
  * Remember directional key layout...

* ptr=CAR -> Yes, Create new list with atom
  -> Points to object
* ptr=CDR -> No, Create new list after
  -> Points to space after or between (nearest object)

##################

EVAL FUNCTIONALITY

How to type functions, args, eval?

(add (a b) (pack a b))

User types/packs:
("f" "o" "o")

Then uses eval command or types it all out and performs eval on the string

(e,v,a,l)

-> pack

(eval)

-> link list

(eval (foo))

-> do eval



User types add:

("a" "d" "d"

#################

NUM FUNCTIONALITY

Use <mod>+NUM to produce a number

Can create option for this...since it is fundamental


In README, go over how we invert the process model and how the current model
has much redundancy and overhead and wasting resources

[![Alt text](https://img.youtube.com/vi/BemmZaOyzbk/0.jpg)](https://www.youtube.com/watch?v=BemmZaOyzbk)


################################################################################

   * Implement Worker cache coherence/sync [Later] -> Work as intended without coherence
     * Workers represent CPUs with cache and Model represents main memory
     * Ctrl/worker sends to render, then sends update to model
     * Model broadcasts (minus sender ofc)
       * Copies one socket to many sockets
     * Workers will sync cache - poll until no messages
       * Workers can sync independently
       * However, workers must sync after every function
         * Alternate read from ctrl/render and read from model
       * Can also explicitly sync cache specific or all
         * Sync will be sent to all workers
         * Then wait on response from all workers
       * Worker A - cache 1/2, fn-1 used node-1
       * Worker B - cache 1/2, fn-1 used node-2, fn-2 uses node-1
         * What if B in middle of fn-2 and does not get the update on node-1
         until after fn-2 is done???
           * Solution is to pull req data from model before fn
           * If worker A fn-1 running before worker B starts fn-2,
             Worker B would have to block until A is done
         * Worker B does not know Worker A modified it and believes its cache is valid
         * Example, task 1 - update colors, task 2 - update positions
           * Need not serialize entire object, only relevant cells
         * As long as sync is performed before hand
           * If required function data known AOT, then batch pull to minimize I/O
       * What if data waiting to be updated in worker B and has already been uploaded to model by worker A,
       is updated by that worker B and overwritten in both model/render?
         -> The work A did is lost and never seen
         -> Question is whether the trigger for that task expected there to be
         possible conflict
         -> Makes sense? Instead of waiting for last operation to complete, just
         perform a new operation - either run serially or in parallel
         * Serial must wait for all workers to sync, and then runs
           * Send sync object, wait for return msg
     * Model can keep track of which process has which vertex
       * On broadcast, Model can check and decide whether to skip
         have the data in their cache only get relevant messages?
       * Might not be relevant since possible at some point, all workers will have
       complete cache of all data
     * Move most recently used data to the front of binary tree
     * For projview, currently only sending the matrix -> create fn to send entire structure
       * Ex: (get attr attr attr ...)
       * Would allow updating only specific members etc.
     * Example: To randomly color all nodes, would split among N processes
       * Each process would fetch a chunk of nodes
  * P2P method?
    * Worker broadcasts to peers and Model
      * Is Model needed? Contains initial data...
      * What if worker needs data that no one has...and how does it decide
      who will satisfy the request...or it creates it and caches it
    * If one worker is slow, then it won't get updates until later


https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glGetProgramBinary.xhtml


AVAIL PTR
(struct (+ 4379328 (* 6 8)) '((B . 8) (B . 56)))

Do size -A ./picolisp
Get .data offset
Or use NIL
Look in base.s to get offset


https://linux.slashdot.org/story/19/05/15/1523252/why-linux-on-desktop-failed-a-discussion-with-mark-shuttleworth?sdsrc=popbyskidbtmprev

#(println (format (get (: dims) 1) *Scl) (format (*/ *adv-glyph Sca-Glyph 1.0) *Scl))


LIST:
CAR=ATOM
CDR=CONS

ATOM:
CAR=<>
CDR=<>

NEED QUOTE OPERATOR
- NO QUOTE IS NORMAL
- QUOTE WILL EDIT THE REP

https://www.phoronix.com/forums/forum/phoronix/latest-phoronix-articles/1114417-wayland-s-weston-lands-a-pipewire-plug-in-as-new-remote-desktop-streaming-option/page3

Wayland and X11 are two very different things and remote desktop is one area where Wayland will always still benefit from a protocol such as X11. For example the best Wayland can do is a slow VNC type approach of sending across a complete raster image (albeit compressed) which requires a lot of bandwidth. An intelligent protocol sends across instructions such as "draw line between x and y". This is how X11 works.

Windows and RDP has even X11 beaten and is thus far ahead of VNC and Wayland when it comes to performance. This is because rather than simply sending drawing instructions, it is aware of widgets and so can send much higher level instructions such as "refresh window", "draw button here", etc.

In short... The *NIX desktop (*NOT Wayland*) needs to up its game if it plans on ever competing in the enterprise with remote desktop solutions again. This needs to be done from the widget toolkit (such as Qt or GTK+), not the underlying platform and certainly not a compositor. Something like this:

Unfortunately due to a very immature Wayland, the Linux desktop is now extremely behind and is at risk of re-entering the "hobbiest / toy" market.


################################################################################


Vertices: a b c

Particle: symbol that contains both vertices and data

Data: "abc"

https://www.mail-archive.com/picolisp@software-lab.de/msg07414.html

On Wed, May 03, 2017 at 10:24:59AM -0800, Christopher Howard wrote:
> Just out of curiosity: does PicoLisp have some mechanism for dumping the
> process image (or some equivalent effect) so you can save a PicoLisp
> process in a certain state and restart it there.


Not completely I think. What comes close would be pretty-printing the values of
all symbols (omitting circular structures which otherwise would cause a hang):

   (out "save.l"
      (for "S" (all)
         (unless (circ? (val "S"))
            (pp "S") ) ) )


On Wed, May 03, 2017 at 09:18:22PM +0200, Alexander Burger wrote:
> On Wed, May 03, 2017 at 10:24:59AM -0800, Christopher Howard wrote:
> > Just out of curiosity: does PicoLisp have some mechanism for dumping the
> > process image (or some equivalent effect) so you can save a PicoLisp
> > process in a certain state and restart it there.
>
> Not completely I think. What comes close would be pretty-printing the values
> of
> all symbols (omitting circular structures which otherwise would cause a hang):
>
>    (out "save.l"
>       (for "S" (all)
>          (unless (circ? (val "S"))
>             (pp "S") ) ) )


Having said this, I must say that I do not see a use-case.

PicoLisp starts blindingly fast by 'loadi'ng source files. And for persistence
we use the database (i.e. external symbols).

################################################################################

http://blog.rongarret.info/2006/10/top-ten-geek-business-myths.html

https://unix.stackexchange.com/questions/364641/mapping-scancodes-to-keycodes

## GC Strategies

Three primary algorithms:
* Mark...
  * Sweep
  * Region
  * Compact
* Stop/Copy (scavenging) - Cheney semi-space
* Noncopying Implicit Collection - Baker
  * Has advantages of both Mark + Stop/Copy
  * Main weakness is fragmentation...but not an issue for PicoLisp?

Mark/sweep is faster when low mortality/high liveliness since less
sweeping is done.

Stop/copy is faster when high mortality/low liveliness due to copying
all live objects.

Mark/sweep uses less space than stop/copy since stop/copy always
reserves half of the space.

Larger objects favor mark/sweep than stop/copying.

Stop/copy defragments by compacting data through copying.

Stop/copy running time proportional to amount of live objects, not the
size of the heap.

Stop/copy provides better worst-case space bounds than noncopying.

In PicoLisp, since everything is a cons cell, the GC can be optimized
around that, which favors stop/copy.

https://www.quora.com/Which-type-of-garbage-collection-mechanism-is-more-efficient-mark-sweep-or-stop-copy
https://www.hboehm.info/gc/complexity.html

Give user option:
- Expand heap
  - Can only expand until run out of memory
- Collect heap
- Fork+Collect heap
  - User must do side-effect free operations until

Scenarios

* Side effects involving resources, such as I/O, are an issue
  * Need custom syntax/fn to specify function is not pure

* Fork + Mark/Sweep
 * Fork on GC
   * Needs size of heap so mem capacity limited to half of total ram
   * Speed depends on heap size
   * Twin procs would amortize deltas at the expense of space vs fork
 * Mark-Sweep
 * Replay eval
 * Switch process
 * Misc
   * To maximize CPU throughput, do parallel mark/sweep/compact
     * Each heap/1 MB chunk
   * Partition heap into N CPU segments, join after all done

* Short Term (feasibility/suitablility, greatest->least):
  * GC not feasible/suitable -> Need semi-auto memory management
    * Per-frame Allocation
      * Runtime
        * Init/manage heap
        * Provide allocation functions - pointer bumping
          * Some allocations have to be automatic
      * On frame start:
        * avail-start = cons (or avail cons)
      * At frame end:
        * avail = avail-start
        * Any data created between those points, will be overwritten
        * For static data, memcpy to next module/frame before ptr reset
          * Copying GC basically...
      * Almost generational...
      * Create heap large enough that GC need not be triggered
        * Copy to another process while previous GC's
    -->> Modfy heap function to take a number that will set the avail pointer
    * For now, make heap large enough to prevent GC
      * Can track usage (+/- 1 MB granularity) after every eval
      * Inform user, ask to GC or resize heap
    * Hooks
      * Runtime allocates enough for default/protected symbols
        * Namespaces are like areas?
      * Alloc functions need heap pointer to allocate/link cons cells
  * TODO
    * Remove checks from cons* fn's in GC to disable GC mark/sweep
      * Maybe have function that swaps pointer functions
      -> Need it as backup if memory is full
    * Add function to get/set Avail ptr
      -> Modfy heap function to take a number that will set the avail pointer


## RESEARCH

DL
https://www.youtube.com/watch?v=R7EEoWg6Ekk

https://academia.stackexchange.com/questions/109/is-there-any-efficient-non-linear-note-taking-software

Write PicoLisp ("A") interpreter in PicoLisp ("B") -> AKA meta-circular interpreter
Have A do optimizations:
- AST rewriting
  - Replace optimized nodes with machine code

http://doc.rix.si/cce/cce.html

Biggest emacs issues:
1. Concurrency - operations/fns locking up interactiveness
2. C Core

Javascript Engines
1. QuickJS
2. ducktape
3. Jsish

https://news.ycombinator.com/item?id=20411154

################################################################################

We can create screens...but make them nodes also

https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/

Should write down cases and use as tutorials/examples

################################################################################

https://www.mail-archive.com/picolisp@software-lab.de/msg07287.html

> (list (box) (box) (box))
> ...
> ($177760526373112 $177760526373114 $177760526373116)


> Where each memory location is two more than the previous. I am wondering

Yes. BTW, these are actually cell addresses, not bytes. The values have to be
multiplied by 16 to get the physical addresses. And the value is printed in
octal representation.

Two cell are created for each symbol here, one for the symbol itself and one for
the list being built.


> if this behavior is guaranteed to always be the case, the implication

The observed offset of two is not guaranteed. Cells are picked sequentially from
the heap in the beginning, but from the Avail list after garbage collection, and
are not predictable.


> being one could have random access to any cell provided he knew the
> address of the first cell.

Correct. There is even a function for that, 'adr':

   : (box)
   -> $377166006651

   : (adr @)
   -> -34256457129

   : (oct @)
   -> "-377166006651"


  #{

      1. (X) . (()   Fn))
      2. (X) . (Ctrl Fn))

      Problem! -> 1 is always found first so 2 never executes

      Bitmask?

      1. (X) . ( (()   Fn)
                 (Ctrl Fn)
                 (Alt Fn)
                 (Shift Fn) )

      Hold Ctrl, Press X

      1. assoc ctrl -> no exist
      2. assoc x    -> list exist, assoc x list, check times
  }#


(+ 1 2)
"(+ 1 2)"
+ 1 2

+
Intern
1
2
Eval


https://www.osnews.com/story/18829/pt-i-spatial-memory/

################################################################################

DISPLAYS

list
- horizontal
- vertical

special

- de
  (de add (a b)
    (+ a b))

- let
  (let (a b
        c d)
    (+ a c))


- for, loop, while
  (for (I 0
        (< I 10)
        (inc I))
    I)

- if, cond, when
  (if (= A 1)
      NIL
      T)

################################################################################

Poss to draw structures directly by traversing pointers

However, must store vertices somewhere

Another issue is if cell is garbage collected, no way to know, thus cannot free
vertices. So if vertices were stored in an assoc list - ptr:verts, have no way of knowing.

User must explicitly add/remove data

DATA: [.|.] -> [.|.] -> [.|.]
      |        |        |
REPR: [.|.] -> [.|.] -> [.|.]

Particle
- Dat (CAR)
- Lnk (CDR)
- Verts

(list 1 2 3)

Particle 1
- 1
- Particle 2 = (2 3)
- [1]

Particle 2
- 2
- Particle 3 = (3)
- [2]

Particle 3
- 3
- NIL
- [3]


################################################################################

Ctrl tab will make cons
- For now, create on new line

Up/Down - move between cons
Left/Right - move between atoms

( T (a b c (d e f) g) (1 2 3) T )

.
  T
  . a
    b
    c
    .
      d
      e
      f
    g
  . 1
    2
    3
  T


(de add (a b) (+ a b))

(de add (a b)
  (+ a b))

.
  de
  add
  .
    a
    b
  .
    +
    a
    b

Default to code blocks like paredit

Treemap

Graphs are inefficient for scaling

http://www.cs.umd.edu/hcil/treemap-history/


################################################################################

https://news.ycombinator.com/item?id=15466124
https://news.ycombinator.com/item?id=1878220


 sedachv on Nov 7, 2010 [-]

Lisp Machines are something that you think is really cool when you first learn about them, then you come to the realization that pining for them is a waste of time.

I've had a flash of inspiration recently and have been thinking about Lisp Machines a lot in the past three weeks.

But first, a digression. There's an important lesson to be learned about why Symbolics failed. I think Richard Gabriel came to the completely wrong conclusion with "Worse is Better" (http://www.dreamsongs.com/WorseIsBetter.html). There are two reasons why:

1. Out of all the LispM-era Lisp hackers, only RMS understood the value of what's now known as Free Software. (If you haven't read it yet, read Steven Levy's Hackers - it describes the MIT/LMI/Symbolics split and how RMS came to start FSF and GNU).

2. Portability is really important.

The key lesson to draw from Unix isn't that "Worse is Better," it's that survivable software is Free and portable. Free because getting software to someone's harddrive is 80% of success, and portable because you don't know where people will want to use your software (there are some really weird places).

Symbolics was neither. If Genera had been Free Software, it would by definition still be around today. If Genera had been portable, it's likely Symbolics would never have gone out of business (the Alpha virtual machine would have been done sooner, with less resources, and for more systems).

Being released as Free Software today wouldn't help. Genera's predecessor, MIT CADR, was made available under an MIT-style license in 2004 (http://www.heeltoe.com/retro/mit/mit_cadr_lmss.html). There's a VM emulator which runs the code. The whole system is pretty useless.

Now on to the inspiration part:

It's possible to make a very high-performance, portable Lisp operating system on modern hardware. This has been a possibility ever since the Pentium came out. The main bottleneck to conventional Lisp runtime performance is the way operating systems manage memory allocation and virtual memory.

A type-safe runtime that has control over memory layout, virtual memory, and is aware of DMA can provide extremely high throughput for allocation and GC (this has been shown by Azure's Linux patches for their JVM), true zero-copy I/O, almost optimal levels of fragmentation, and excellent locality properties. If you go single address space (and there's no reason not to) and move paging into software (object faulting and specialized array access), you've also eliminated TLB misses.

Throw in the fact that it now becomes trivial to do exokernel-type stuff like for example caching pre-formatted IP packets, and it should be possible to build network servers that have throughput many times that of anything that kernel/user-space split OSes like Linux or FreeBSD are capable of for dynamic content (ie - not just issuing DMA requests from one device to another).

The only problem is device drivers. Lisp doesn't make writing device drivers any more fun, or reduce the number of devices you have to support.

What to do?

The reason I've been thinking about this is that I came across this: http://www.cliki.net/Zeta-C

I've heard of Zeta-C multiple times before, but for some reason this time I made the connection - "why not use Zeta-C to compile an OS kernel?"

I explored the idea further, and it seems to me that it wouldn't be an unreasonable amount of work to take the NetBSD device subsystem and have it running on top of a Lisp runtime with the necessary emulation of those parts of the NetBSD kernel that the drivers depend on. If you don't know, NetBSD's device drivers are modular - they're written on top of bus abstraction layers, which are written on top of other abstraction layers (for example, memory-mapped vs port I/O is abstracted). So the actual system twiddling bits can be neatly encapsulated (which isn't necessarily true for Linux drivers, for example).

I'm aware of Movitz (http://common-lisp.net/project/movitz/) and LoperOS (http://www.loper-os.org/). Movitz makes the mistake of trying not to be portable, but there's useful things there. I haven't spoken to Slava about this yet so I don't know what's going on with LoperOS. I am also aware of TUNES, and think it was an interesting waste of time.

The main thing is to get Zeta-C to work on Common Lisp. Then it's to build a new portable, boot-strappable runtime (I think the Portable Standard Lisp approach of having a SYSLISP layered on top of VOPs is the right way to go for this), and either build a compiler targeting that runtime, or adapt the IR-generating parts of one of SBCL, CMUCL or Clozure. Further bootstrapping can be done with SWANK and X11 once a basic networking stack is in place. I think such a system would be quite fun to hack on.

If you've gotten this far, let me know what you think about this idea. I also have some preliminary thoughts about how this can be worked into the base of a new high-performance/scalability transactional database startup, if you want to hear about that email me: vsedach@gmail.com


########################################################################

When data is created, such as through key presses, the output is added
to the space symbol list, and the cmd(input) is added to the time symbol list.

Time Sym:
create-char(NIL)=A [or NIL is Space sym itself]
  (move-ptr)
create-char(A)=B
  (move-ptr)
create-char(B)=C
  (move-ptr)
cut-char(C)
  (move-ptr)
cut-char(B)
  (move-ptr)
cut-char(A)
  (move-ptr)

Space Sym:  A B C
Buffer Sym: C B A

Undo-1 = reverse cut-char:
Time Sym:  ( Create-... ((C-C C-C C-C) (P-C)) ... )
Space Sym:  A B
Buffer Sym: C B

Undo-2 = reverse cut-char
Time Sym:  ( Create-... ((C-C C-C C-C) (P-C P-C)) ... )
Space Sym:  A
Buffer Sym: C

Undo-3 = reverse cut-char
Time Sym:  ( Create-... ((C-C C-C C-C) (P-C P-C P-C)) ... )
Space Sym:
Buffer Sym:

On undo, branch will be created:
            *
r r r u u u
->
          *
(r r r  u u ((u)
             (p)))

        *
(r r r  u   ((u u)
             (p p)))

     *
(r r r      ((u u u)
             (p p p)))


Then if user, types chars again, starting from above:

(r r r ((u u u)
        (p p p)
        (r r r)))

[Looks as though three different timelines occured]

OR

(r r r ((u u u)
        (p p p r r r)))

[Makes most sense since ppp is new timeline]

(r r r ((u u u)
        (p p p))
        r r r)

[Not sure how to interpret this...]

Timelines are naturally a binary tree.

Undoing again...

(r r r ((u u u)
        (p p p ((r r r)
                (d d d *))))) = (A B C)

########################################################################
########################################################################

########################################################################
########################################################################

WASM is trying to abstract OS's, however

The solution is not to build yet another abstraction on top of the OS's
different models, but to fix the underlying problem.

The solution to fix the underlying problem of different models is
connected to open-source as the proprietary models became dominant
first, i.e. Windows


If we can interpret fast enough, that relies on source code available
which makes the platform inherently open-source

The security model on desktops and phones need to be fixed, but that
also connects to companies and "walled-gardens"/vendor lock-in.

And that ties further down to having open-architecture which
hopefully RISC can fix

Emacs and Blender provide the most useful examples of success of
communities coming together around a single paradigm
- They are also very specific niches

However, as users become creators and not just consumers, tools like
Blender will become popular to the masses.

The remaining issue is whether its GPL license will affect its
adoption in the long run - which is why Cycles is permissive.

We can build around its data model from the blend file which is not
licensed.

Lisp's success relies on open hardware and hardware GC

Later we can transpile WASM to PicoLisp

Would a game engine like Half-Life be similar?
- Mods/Plugins/Extensions

Web provided a standardized data structure - the DOM - WASM throws this
out. People wanted to do more, so Javascript was invented.

At the end of the day, it comes down to the memory model...WASM will
allow different memory models, but at what cost? An inconsistent system
which creates vulnerabilities?

Apple's walled garden but not be all evil as they restrict what can
and can't be done to provide a consistent user experience...if only
there was an open-source version of them...

################################################################################

Read macros ony apply to strings?

http://pages.cs.wisc.edu/~psilord/blog/28.html

#{

  Default to X layout because of strings
  - Can we mix layouts? Will it confuse the user?

  CAR can be either dir; top-bottom, left-right

  Place dot middle when vertical?
  -> No, destroys grid layout

  X:

    CAR·CDR -> CAR·CDR -> NIL
    |          |
    1          2

  Y:

    CAR·CDR - 1
        |
    +---+
    |
    CAR·CDR - 2
        |
    +---+
    |
    NIL

  Finally layouts can be defined for specific forms, e.g. let, if, cond, etc.

}#

cryptorick
KVMap.l


      * Dir keys move through atoms or list
        * L/R: Prev/Next atom
        * U/D: Enter/exit list
      * When typing characters, layout horizontally
        * If list starts with a string, layout horizontally
        * Store layout type in the particle
      * Anything after/below the list must be updated
      * All data belongs to master list so lists should not overlap
      or be in arbitrary places
      * Store pointers to ends of list to speed up, similar to make/link


 a        b        c
[.|.] -> [.|.] -> [.|.] -> NIL

 a        b        X        c
[.|.] -> [.|.] -> [.|.] -> [.|.] -> NIL

(conc (a b) (x) (c ...))

Must break B-C by modifying the nth's CDR

Con will modify first cell of lst's CDR to point to Any

So append is like (con (nth <last>) (""))


The issue is how to draw the symbol.


OS DEV:


PTR
 |
[.|.] -> [.|.] ->  [.|.] -> NIL


How to tie PTR symbol to the list
Ptr has the property which is the actual obj
We would need to draw the entire symbol and property list
Or pointer is simply a cons

(def *ptr (cons NIL <obj>))

Cannot draw entire symbol without shrinking it
If symbol prop list grew, could not fit it

DO:


PTR-1 -> PTR-2

PTR-2 -> DATA

...


Solution:

Draw object master pointer property list value with quoted symbol "p-1"
- Or master pointer is simply a list of quoted symbols and/or nested lists

+Pointer
-> '(p1...)

Draw symbol "p1" above actual data
- This symbol's value is the data - the symbol itself is not an object

 p1
 |
[] [] [] []

Thoughts:
* Draw pointers objects elsewhere and generate p# symbols
* Pointers can point to other Pointers
  * Check for type of object when using data

Or

Draw symbol/object elsewhere and
draw the symbol on top of the pointed
Use ... to indicate n-cells between CAR and pointed

- Okay to draw same data
-> This breaks consistency?
- If additional objects are drawn between lines then
spacing is irregular, and the only way to mitigate that is
to draw lines between cells - use single line (pipe) rotated+scaled
- It would also require moving objects around
- Draw between cells


Or

Shrink entire symbol/object to fit - use can zoom in to see it

=============================================

Type wherever, like right in the main data, and execute a command or
to be more organized, create a special list stored in an arbitrary
symbol that is used
typing commands

=================================================
=================================================

- Create Pointer class
- Draw Pointer object as part another list...
  - Property: list of syms that point to desired data
- Draw condensed sym with value below
  - Exception to the rule
    - Sym is primitive type so not so bad? Limit number of exceptions to the rule
  - Drawing a line will help understanding
  - Color to differentiate specialization/exception?
  - CDR is typically to the right, but make this exception or use marker to indicate the CDR is below
- Instead of storing properties in symbol, create class, since symbol props are not
draw entirely when above data
  - The value of objects are themselves (or their types)

Multiple pointers will stack which would require moving lines around it
-> Requires spatial data structure for efficiency

- Poss only move affected parts...but need to draw lines to maintain
relationships
  - More explicit, closer in line with user expectations - principle of least astonishment

...
D-D-D-D-D-D-D-D-...

P0    P1
P0    P1
P0    P1
|     |
D-D-D-D-D-D-D-D


vertical   = nested list - scanning vertically determines depth of list
horizontal = same list   - scanning horizontally determines breadth of list


################################################################################
################################################################################

Can't store transient symbols in particles directly...

Symbols can be drawn multiple times so should always be a list

Particles only contains roots

PROBLEM:

Data: (1 2 3 4 5 6)
Part: (1) -> (2) -> (3) -> (4)

After appending need to update all particles before it!!!
Use *particles to map particles to data

Should iterate through data not particles


Delete particle in arbitrary list
-> Deletes particle in particles - DONE

So particle should not have a/b - instead look up in particles


  (c (a b))
                     [a|*]    [b|*]    (SYMS)  a b
                       |        |
          [c|.]      [.|.] -> [.|/]    (CONS)  (a b)
            |        |
  Abst:   [.|.]  ->  [.|/]                     ((a b))

           ^          ^
          / \        / \
           |          |

  Conc:    P     ->   P    ->   N

           P          P    ->   P   ->   N

                      P         P

  (struct (>> -4 (adr *l)) '((B . 8) (B . 8)))


Maybe make all particles objects with property pointing to data
Modify data -> Modify particle
particle/sym ref data

Particles can reference each other spatially
Underlying data reference each other semantically

##################################
##################################

Maintain a pointer for every list?
Or when moving to a new list, make a pointer automatically

##################################

Differentiate behavior for pointer/list creation
* There exists special command to create NIL - maybe Enter/Return
* Creates NIL object like any char
* Must enter list to switch to it and append items
  * User can "attach" pointer to current list with cmd -
  this is really just creating a new pointer...
  * This allows user to differentiate whether they want to treat NIL as a list
  or a symbol

* Pointer management
  * User has master pointer in pointer list which points
  *0
  (p1 p2 p3 p4 p5 p6 p7 p8 ...)
  * Accessed programmatically or numerically
  * User can switch between manipulating *0 or whatever it points to
  * If pointer points to a pointer...either get last pointer or subpointer...
    * Traverse like a list/cons using arrow keys

Editing middle item will cause chain reaction of position updates
* If list is vertically split, then each item is updated
* Then these updates must be done piecewise since for a very long list
it would block

The lisp code itself is a scene graph

Mixing list orientations will be messy

The drawing layout is actually grid based, based on the adv width and nl height

Set limits:
Strings = 72 (PEP)
Lists/Atoms (non-str) = 12

Drawing vertically, any post lists need to be redrawn
- cache the list traversal should help with this

tree view (aka windows dir) is most familiar to people

see apse

KEY FEATURES FOR NOTE-TAKING/PERSONAL KNOWLEDGE DATABASE
* Local
* Search
* Sync
* Web Clipper
* ScanTailor
* Collaboration
* Native - wait for pil21; until then, create web version
* Export data to plaintext, PDF, Markdown, ODF/ODT

* PDF/Markdown/RSS


CALL THE DEVICE A NOTEBOOK

https://news.ycombinator.com/item?id=19552221
If you practice GTD like me, you need a trusted repository for capturing
   your thoughts, items, todos, etc. It should be fast and easy and available
   everywhere. Thats The value prop that EN brings to the table. No matter
   what it is you want to capture and store, no matter what platform, they
   have a way to quickly and easily do it. You can even email notes right into
   it (they give you a special email address) which I use for things like tech
   newsletters and stuff. So while you are right that notes apps have been
   around, its the little things that really make the difference here.



TODO: Matrix for Competition Pricing

Smartphones are diverging in functionality?

Create "Particle devices" when we get web browsing ability

How to reference object B from object A text?
- ext sym name
- tags...all...or use specific title tag if available
- both?

+Note # or Node
tg:()     #list of tags; always simple symbols/strings; order matters like when searching
nm:"..."  #opt; used for linking, else raw sym used
data:"..." #data; only string? ...later img/aud/vid
date:
desc:

#############################
#############################

IF A METHOD USES AN OBJECT...
MAKE IT A FUNCTION

#############################
#############################

BUG?...
(let Data '(NIL)

Heavy usage of javasript causing web to lose accessibility since
the DOM provides a standard structure easily parsed - the DOM is
data, not code.

https://itnext.io/why-are-we-creating-a-javascript-only-world-wide-web-db8c3a340b9

part-main = [CUR old old old ...]
all these lists are ref'd from elsewhere, master or intra, to prevent GC

Separate command to create root list

So the question is whether user can create new roots
or all new objects/lists are sublist of root
-> KISS, use latter
so part-main should never change

Next issue is how to handle modifying layouts of nested lists
Could flatten and use linking (pointers)
-> Tree/graph data difficult to manuever?

Single edit would cause chain reaction of redraw
To optimize, create list at end then move

Two main orientations:
* Desktop - Widescreen so favor horizontal
  * Layout like win dir since users most familiar with that
* Mobile - Tallscreen so favor vertical

When drawing simply change the list length before newline

Still the issue of sublists:
* Atom spacing maintained
* List spacing maintained

If newspace, how to link them?

The problem is when pointer over NIL, don't know if next key press will append
at that point or append to new list

Or to show it move underneath and make upside down?

Or instead of () -> (NIL)

##############################

To utilize external symbols, only need to manage databases
and then setup classes with relations

1920*1200*4 = 9000 kb = 8.8 MB
100 mb = ~ 10 HD images

How to diff symbols/lists? (nums are atomic)
List is easy
Symbols are based on lists

obj distribution
https://www.mail-archive.com/picolisp@software-lab.de/msg03305.html

################################
################################

cirru editor?

leo editor?

Every particle has the ability to be tagged

"this is a sentence with a " link "in it that has further info"

Particle data:

[.|.]
STR

[.|.] -> [.|.] -> [.|.] ->
STR      LINK     STR

Here, user must break string at desired point to insert link
A function would be best here

Options:
1. Break by new line, goto line
  -> Or use function to go to line and break

We are an OOUI

Computer initially programmed by text/symbols but it has evolved
beyond that - doesn't mean we need to through out text but we
need to incorporate other methods of communication.

So if we could incorporate the features of Emacs but instead of
solely applying that to text, we apply it to any data.

Why emacs fail at discoverability?

Take MS office for example - the ribbon
User can go through all the menus to find what they are looking
for. Sure, it can be a waste of time but its still faster than
trying to figure out a command which means going through the manual
or finding it through google...
If emacs had a default search bar, it would make it so much more
convenient for users

Implications for Particle
* Need an equivalent of menu (menu list) - layout all the bindings
and commands - expose the basic ones
* Need a more explicit search bar (lets call it search list)
  -> A symbol called search-list which has a list user adds to
    ((cmd-1 (result ...))
     (cmd-2 (result ...))
     (cmd-3 (result ...))

Focus on the idea of lists will make it easier for a user to
understand because of the analogy

Emacs difficult because multiple ways to do things and no default
way to do it

Emacs buffer is an interface to the interpreter

lem vs emacs?

THE FUTURE?
WASM -> LLVM IR -> TGT

Reality is just a convenient measure of complexity
-alvy ray smith

===============

(a b NIL)

[] -> [] -> [] -> NIL
a     b     |
            NIL

vs

(a b (NIL))

[] -> [] -> [] -> NIL
a     b     |
            [] -> NIL
            NIL


If user "enters" NIL (aka empty list), replace it

[] -> [] -> [] -> NIL
a     b     |
            NIL (-> X)

Replace CDR of b - so get previous upon enter
Should use spatial get instead of list traversal

(a b (x))

[] -> [] -> [] -> NIL
a     b     |
            [] -> NIL
            X

The Sad State of Personal Knowledge Bases

So all knowledge can be seen as connected,
but all knowledge can also be put into hierarchies.
Concepts and how those concepts are related is something that people come up with,
rather than being an inherent property of the universe.

The idea of forcing yourself to put knowledge into hierarchies is that it makes your thinking more clear,
makes it easier to remember where things are,
and perhaps paradoxically makes it easier to see how things are related.
(Or at least highlights certain types of relationships
that are only visible in the context of hierarchies.)

I'll admit it's pretty weird at first to only get one root node,
I think it took me a couple years to get used to that.
But once I embraced it the benefits quickly became clear.


It is not about store and searching information but
having ways to structure and visualize it


Tags speed up searches by avoiding full text

(find-tag these are some words)
(find-tag (these are some words))

OR = find at least one of the tags
AND = find all of the tags
FIL = filter left to right

To automake tags, ignore common words

Build DSL for it

Test DB up to 50 GB

Build different data structures to simulate
YT, IG, FB, BLOGs, TODO LISTS, GITTER/CHAT, etc.

Need to optimize/shortcut string input so users aren't constantly
packing
- auto make strings after a certain length
- if we hide the conses shouldnt be too bad
- also hide the quotes
- start string when typing, end upon mod+Enter or mod+Space
- or time-based, if user stops typing string is automatically made
  - make sense with stop and go thinking


=======================


Store particles in db
Store gpu buffers in db

[DISK/DB] -> [RAM]

Data created by user...need classes for basic types

+Sym - needs a name

                        cell [PARTICLE]
                          |
              +-----------+-----------+
              |           |           |
           Number       Symbol       Pair
                          |
                          |
     +--------+-----------+-----------+
     |        |           |           |
    NIL   Internal    Transient    External

Particle
  Atom (Number/Symbol)
  Pair
    len

Length for pair, symbol, number
Default for strings is to pack until user creates non-string
or presses <mod>+Enter
-- easier for users
-- or remove quotes ... or draw lighter
   -- maintain consistency with reader

Whhat if uesr wants to tag part of the string?
-- Move pointer and tag
-- Or split it

[.]
("this is an important word that needs to be marked")

[.]
[.]                     [.]    [.]
("this is an important" "word" "that needs to be marked")

Instead of breaking the string apart, the tag simply maintains
a pointer to it with pos in string

This goes into string manipulation...
User can extract the word by breaking the string into words
- using split
Without that, can calulate which char based on distance

chop (by space etc; list uses split)
mark range of list
tag
pack excl tagged

FINAL VERDICT:
Focus on bigger picture; worry about this later...
For now, we can tag particles aka lisp data.
If user really wanted it, they could refactor into another
item in the list

Question is whether it should be made visible:
("The quick brown fox jumped over the fence")
("The" "quick" "brown" "fox" "jumped" "over" "the" "fence")

Poss draw without quotations or make them very light
Poss indicate with color instead

Spaces would need quotations still

Raw verbatim text search is triky; poss use other methods to
narrow range before performing full text search which would
require combining strings into buffer before actual search

Without the above example, only break apart strings, as needed

Default mode could be to create strings when user presses space
-> PROBLEM, how to create strings with spaces?
   -> Use cmd

what if user initiates with quotes? can't close with quote...
must escape it...

================

The Use of Space in Text Editors

================

How to mix layouts?

Layout property belongs to each list:
(+/-|X/Y LEN)

Pos/neg means direction perpendicular

'x

[.|.] CDR
CAR


'y

[.|.] CAR
CDR


Given LEN=2

'x

[.|.] -> [.|.]

CAR      CAR

(cont. from above end)

[.|.] -> [.|.] CDR

CAR      CAR


'y
          (cont. from left bottom)

[.|.] CAR  [.|.] CAR

 |          |
[.|.] CAR  [.|.] CAR

           CDR


Layout only applies to top level atoms;
any sublists have their layout defined

When lists are drawn, its bounds are saved
Upon any of its items moving, the bounds are updated


Full X layout with nested lists

A A A .             A A A
      B B .     B B
          C C C


So if C gets another item, B.X inc, A.X inc
Subsequent items in B and A must move forward


A A A .           A A A
      B B .   B B
          C C
          C C
          C ...

If C is vertical, then parent lists do not need subsequent items moved


Layout Strings

Must specify:
1. Direction of CDR = X or Y
2. Direction of CAR/growth = For X, grow up or down; For Y, grow fwd or back
3. Max length

* When length = 0, #2 negligible
-> This means combine 3 into 2, it's either 0 or +/-#

* Char codes can be used for newline and tab

* Offset codes relative to base
  (NUM AXIS)

Typical let statement:

(let (A B
      C D
      ...)
  E
  F
  G
  ...)

Let has vert orientation with exception - draw first two hor
List ABCD has -X orientation with length=2
  - Neg bc items grow -Y
  - X bc CDR across
List EFG has -Y orientation with length=0
  - Neg bc items grow -Y
  - Y bc CDR below
  - 0 means single column/row so growth is negligible

Results in:

((-X 1) (-X 2) ^J
 (2 X) (-Y 1))

This means 1st item use 1st
second item use 2nd
^J means move to newline
offset 2 spaces in x direction
3rd and remainder uses 4th


TODO:
1. Draw lists/layout
2. Calculate bounds
  * Use global vars instead of passing between functions
3. Test mixed lists and reflow with random modification


DID WE JUST CREATE A DSL FOR LIST LAYOUT/DRAWING?

Note, changing bidirectional layouts will cause search before AND
after

=====

Each process will store a local cache of a symbol
- Cycle of read, modify, draw, write - repeat
However, all processes will push the generated data to rasterizer

How to draw a list when an item in the middle is modified
-> Must know its index
-> So must traverse list from beginning - find item in list
-> Cannot consistently cache index
-> Can cache provided nothing before it is modified
   at that point, it must be discarded
-> Cache store the last accessed CDR in the main list
   so if user added items multiple times in a row, it can
   reuse it; afterwards, empty it


UNDERSTANDING CODE IS HARDER THAN EXPLORING IT

===============================================

How To Handle Mixed Layouts

Check if prev (car/cdr) is opposite layout

For example if default is y but prev is x
must use final y from prev

  #{

    [] -> [] -> []
    |     1     2
    |
    [] -> 3
    |
    [] -> 4


    [] -> [] -> 1
    |     |
    |     [] -> 2
    |
    [] -> 3
    |
    [] -> 4


    [] -> [] -> []
    |     1     2
    |
    [] -> []
    |     |
    1     2

    3 variations with spacing - either top/bottom is closer to base
    or equidistant

  }#

===================

We can define symbols as "tags for data"
(objs are symbols so symbols are objs)

Conventional programs focus on the data and attaching tags

What if we focus on tags and then attaching data to it?

A tag viewport can be positioned L/R or T/B, since we use a tile layout
* Really just a generic viewport, that the user can have a camera follow
a list, either adjust zoom+pan to fit entire object or only part of it
etc.

If everything is a symbol then it can be tagged!

There exists other objects like lists and numbers,
and of course, other symbols like strings
so how do those get tagged since they are no symbols?

-> Use a symbol to store the object, and then tag it by adding to its
tg list

In other words, create a Particle that stores the object (its value)
and add to its tg list

In this case an external object is used
which has a unique numeric id
based on its position in the file/block/offset

It can also be referenced through the tags that it has
(this is the expected way to find it)

Since everything the user sees is a particle, it can be tagged
-> EVERYTHING IS TAGGABLE...


However, symbols can contain a list etc. - compound structures
So in order to tag individual parts in the compound structures,
they must be broken out somehow

For example, a symbol contains a list of words - no, each word in the list
is actually a particle so they can be individually tagged.
However, if a part of a string is to be tagged it must be broken out

IDEA!

Given:

("The quick brown fox jumped over the fence")

Break out words in a sublist:

( ("The quick brown fox jumped over the fence")
  "fox" [tag this]
)

However, what if the user edits the string?
-> Then user must edit list
-> Makes sense since it is not a valid tag...
-> This can be made automatic so that it is cleared
when the string is edited
-> User might want to keep it so what is the default?
-> KISS and Principle of Least Astonishment
-> Best way would be if the word is removed from the string,
the tag should be removed also

( ("The slow grey elephant jumped over the fence")
  [nothing here anymore]
)

At this point, this list of tags should become a property of the particle
or more specifically for a string/symbol particle

For the tagged word in the property list, it would need a property to store
addtl info (instead of a string symbol, make it a particle or subclass of it)
such as pos so that we can tell if it has been modified

===========

PicoLisp has a spatial structure but only works in +X and +Y...
We can create for db files, depending on the quadrant the object lies in

===========

How To Link Symbols?

Create Link object, which contains the external/internal symbol

WHAT IS OUR MVP

===============

How To Create A Tree Structure

  ("I"
    ("I.A")
    ("I.B"
      ("I.B.1"
       "I.B.2"
       "I.B.3"))
    ("I.C"
      ("I.C.1"
       "I.C.2"
       "I.C.3")))

I .   .              .
  IA  IB .           IC .
         IB1 IB2 IB3    IC1 IC2 IC3

* Add "I"
* Add NIL
* Enter list
* Add "I.A"
* Exit list
* Add NIL
* Enter list
...
* Exit list
* Add NIL
* Enter list
* Exit list


MIXED ARBITRARY:

. . . A
A A . A
    . A
    . . . NIL
    A A A

Modifying mid-list would result in relayout


============================================

A list/pair would contain vol for all items in list until NIL
A num/sym would contain vol for direct CAR and CDR

Calc vol for a pair = vol cell + vol CAR + vol CDR + spacing

[.] CAR
    asdf
    asdf
    asdf

[.] CAR
    adsf
    adsf
    adsf

[.] CAR
    asdf
    adsf
    asdf


      (NIL)
[.] - [.] - NIL
      NIL

      ("A")
[.] - [.] - NIL


      [.]
      "A"


((CAR))

[.] - CDR
CAR
 |
[.] - CDR
CAR

(CAR CAR)

[.] - CAR
CDR
 |
[.] - CAR
CDR


Pressing ascii key results in replacing CDR
except when enter-list is called
which results in replacing the CAR
then returns to normal

https://news.ycombinator.com/item?id=17892731

How would data be sorted according to date/time versus tags alphabetically?

-> Query objects, then produce lists of list

((date obj-val)
 (date obj-val)
 ...)

If user wanted to change it, they produce a new list

((tag-a obj-val)
 (tag-aa obj-val)
 ...
 (tag-b obj-val)
 (tag-bb obj-val)
 ...)

Should entire property list be shown? ...which the user can edit directly

((3 . tag) (2 . time) (1 . date))


Right now we are producing lists of strings but eventually these strings
will be stored in an external symbol (Particle)
- Strings are made of particles and when joined become a single particle

So how does a user generate a new ext symbol?
-> Need command ... use ctrl enter or something
  -> Sym is added to main list
  -> User moves to it property list value
  -> Modify
  -> Commit

Create user property for user properties?


=========================================

NIL solution:

[]
NIL

*0
<>

============

[]

*0
NIL



enter list == point to car

Two scenarios upon enter list

Scenario A:

[ ] -> CDR
NIL (*)


Scenario B:

[ ] -> CDR
 |
[ ] (*)
"x"

Flag will be set and then repl-part must determine if Ref is NIL or Pair

This can be used to replace any item in a list

In reality replacing the CAR means replacing the entire list

In Scenario A:

(NIL) -> ((""))

In Scenario B:

(("x")) -> (("x" "y"))

Same as default

  Solutions:
  * Append after (expected)
  * Replace
    * People rarely use insert mode
    * Can be done with combination of del + char
    * Backspace will move ptr to prev of ref
    * Delete will move ptr to nxt of ref

#########################################

Layouts - X

[ ] [ ] [.]          [.]         NIL
" " " "

        [ ] [ ] NIL  [ ] [ ] NIL
        " " " "      " " " "

* Less compact; easier to see diff between lists
* Only previous item need be redrawn

Another way is to stack sublists to maintain top-level spacing:

[ ] [ ] [.] [.] NIL
" " " "

            [ ] [ ] NIL
            " " " "

        [ ] [ ] NIL
        " " " "

* More compact; easier to see same list relations
* Every single item previous must be redrawn (adjusted downwards)


Layouts - Y

[.] [.] "I"

    [.] [ ] "A"

        [ ] "B"

        [ ] "C"

[.] [.] "II"

    [.] [ ] "A"

        [ ] "B"

        [ ] "C"


Layouts - Mixed


[.] a

[.] b
*0
[.] NIL
NIL


Enter list ->


[.] a

[.] b

[.] NIL
NIL *0

* Should be above?
* Under makes it consistent with x layout


->


[.] a

[.] b

[.] [.] c
NIL     *0


=================

What if pointer is part of the list itself?

Given: [1] -> [2] -> [3] -> [4] -> NIL

*0 -> [1] -> [2] -> [3] -> [4] -> NIL

[1] -> *0 -> [2] -> [3] -> [4] -> NIL

[1] -> [2] -> *0 -> [3] -> [4] -> NIL

[1] -> [2] -> [3] -> *0 -> [4] -> NIL

=====================================

[.] *0

    [.] "I"

    [.] [ ] "A"

        [ ] "B"

        [ ] "C"


[.] [.] "I"

    *0

    [.] [ ] "A"

        [ ] "B"

        [ ] "C"


[.] [.] "I"

    [.] *0

        [ ] "A"

        [ ] "B"

        [ ] "C"

This will allow to keep the structure in tact

.............................................

What about maintain space between sublists to avoid redraw?

*0
[.] [.] "I"

    [.] [ ] "A"
        [ ] "B"
        [ ] "C"

[.] [.] "II"

    [.] [ ] "A"
        [ ] "B"
        [ ] "C"

((I (A B C))

1
2 *0
3 [.] [.] "I"
4     [.] [ ] "A"
5         [ ] "B"
6         [ ] "C"
7         NIL
8     NIL
9 NIL

1
2 [.] *0
3     [.] "I"
4     [.] [ ] "A"
5         [ ] "B"
6         [ ] "C"
7         NIL
8     NIL
9 NIL

Still have to move items on that line so a really long horizontal list would
take long

=======================

What about pop object?

[1] [2] [3] [4]

    [2]
[1] *0  [3] [4]

        [3]
[1] [2] *0  [4]

            [4]
[1] [2] [3] *0


What about pointer jumping?

Bad idea


So keep current idea
For y layout, create column spacing which is equivalent to row spacing for x
and put pointer on left instead of above
Draw pointer down? What if number doesn't fit? -> Space up to 3 digits, shouldn't be more than that...
Many column spacing would be consistent with x layout though

[.] * [.] "I"
      [.]     * [ ] "A"
                [ ] "B"
                [ ] "C"

What about underscore or bounding box like traditional?

=========================

Make pointer just p or *

              *
ptrs *0 p1 p2 p3 p4

     *
main a b c

Or double space the x atoms to match double space of y layout

[.] [.] "I"

    [.] [ ] "A"

        [ ] "B"

        [ ] "C"


[ ]  [ ]  [.]            [.]            NIL
" "  " "

          [ ]  [ ]  NIL  [ ]  [ ]  NIL
          " "  " "       " "  " "

=======================================

Use Toggle

Make entire thing a single list

  (I Title
    A Title
    B Title
      1 Hello World
      2 Foo Bar)

However, doesn't make much sense since would require using headers as tokens and default the whole purpose of structure

Header at start of every list

  (I Title-Body
    (A Title-Body)
    (B Title-Body
      (1 Title-Body)
      (2 Title-Body)))

Then should header lists be grouped into a list?

  (I Title-Body
    ((A Title-Body)
     (B Title-Body
      ((1 Title-Body)
       (2 Title-Body)))))

Pattern becomes:

<head> <body> <subs>

Seems reundant since getting Cdr after Title-Body would return a list

Choose simplest!

Thus:

  (I Content
    (A Content
      (1 Content)
      (2 Content))
    (B Content
      (1 Content)
      (2 Content
        (a Content)
        (b Content))))

  * How does user specify CDR is on newline...newline char?
  * [Y] can be at end of line or start of line

  [Y]  [X]  [X]       # If CDR missing, then newline; align to first item
       I    Content

       [Y]  [X]  [X]
            A    Content

            [Y]  [X]  [X]       NIL
                 1    Content

            [Y]  [X]  [X]       NIL
                 2    Content

            NIL

       NIL

       [Y]  [X]  [X]
            B    Content

            [Y]  [X]  [X]       NIL
                 1    Content

            [Y]  [X]  [X]       NIL
                 2    Content

            NIL

       NIL
  NIL

Alternative

  [Y]  [X]  [X]      [Y] CAR
       I    Content  CDR

            [X]  [X]      [Y]   # So CAR is next line?
            A    Content  NIL

                 [X]  [X]      NIL
                 1    Content

                 [X]  [X]      NIL
                 2    Content

==================

[ ] CAR
CDR

[ ] CDR
CAR

(when (isa '+Pair (get Pair 'b)) # instead of a Sym/Num
  (put (get Pair 'b) 'lay 'y))

  [Y]  [X]  [X]       # If CDR missing, then newline; align to first item
       I    Content

       [Y]  [X]  [X]
            A    Content

            [Y]  [X]  [X]       NIL
                 1    Content

            [Y]  [X]  [X]       NIL
                 2    Content

            NIL

       NIL

  NIL


  [Y]  [X]  [X]       # If CDR missing, then newline; align to first item
       I    Content

       [X]  NIL

       [X]  [X]
        A    Content

       [Y]  [X]  [X]       NIL
            1    Content

       [Y]  [X]  [X]       NIL
            2    Content

       NIL

  NIL

================================================================================

Implement:

* Change Ptr-Ref
  * layout: x, y
  * new row/col
    * Changing this will move obj to newline and redraw cdr
  * Reflected in object
* Change New
  * layout: x, y
    * Default will be based on current Ref
  * new row/col
  * Reflected in Ptr name

* +Pair always Y
* +Atom always X; newline is exception
  * Mark in +Atom if newline - stored in Prev or Nxt?

* Refactor layout algo to draw test structures

  [Y]  [X]  [X]
       I    Content

       [Y]  [X]  [X]
            A    Content

            [Y]  [X]  [X]       NIL
                 1    Content

            [Y]  [X]  [X]       NIL
                 2    Content

            NIL

       NIL

  NIL

'(("I" "Content"
    ("A" "Content"
      ("1" "Content"
       "2" "Content"))))

What if instead of:

(I ... ...
   (A ... ...
      (1 ... ...
      (2 ... ...
   (B ... ...
      (1 ... ...
      (2 ... ...
(II ... ...
...

User wanted:

I ... ...       II ... ...       III ... ...
  (A ... ...       (A ... ...
     (1 ... ...       (1 ... ...

Or even

I ... ...       
  (A ... ...       (B ... ...
     (1 ... ...       (1 ... ...

Need a markup language to express this...

To say

Y layout for first level
X layout for second level
... layout for ... level

(Y X ...)

If data exceeds length of markup, default would be to use last one
-> Specify R for repeat?

(Y X R) = (Y X Y X Y X ...)

This markup data is passed to lay-part function
-> Need to track level also

To pre-defined layout for special forms:

(let (a 1
      b 2
      c 3)
      
  body-1
  body-2
  body-3)
  
(let a 1      
  body-1
  body-2
  body-3)  

Old Notes:

(X (X 2) ^J
 (2 X) (-Y 1))

This means 1st item use 1st
second item use 2nd
^J means move to newline
offset 2 spaces in x direction
3rd and remainder uses 4th


(let (a 1
      b 2
      c 3)
      
      body-1
      body-2
      body-3)

NIL -> when atom added, must move below and convert to Y
Change symbol

================================================================================

  mixed Y
  
  .   ..
      "A"
  NIL


  pure Y
  
  . *cmd
  .   .. "A"
  .   .. "B"
  NIL    


  [X]  [X]  [X] NIL
  A    B    NIL


  TO:

  [X]  [X]
  A    B  

  [Y] C
  CDR
  
  * Store list in main to get the base pos x
  * Assumes list defaults to newline
  * Instead of creating nil, can just create new list
  
  * Should enter move ptr to newline?
    * To make this consistent, ptr should point ahead of NIL
    * OR have it point to NIL and when user enters newline, move CDR below
  
  * Default create nil just appends NIL, but does not enter it
  
  Three Methods
  
  * Create NIL, then enter list mode (which moves NIL to nl), mov ptr, enter char
  
  * Enter list mode (creates NIL on nl), mov ptr, enter char
    * Move NIL below like latter
    * Next char will be first item
    
  [X]  [X]
  A    B  

  [Y] NIL
  NIL

  * Create list with Char
    * Combo of above
    * No default combo like newline+char (although could be done with a macro)

================================================================================

Lets start with manual layout
so place NIL either normal or next line
-> Newline ref
-> Layout ref

Ex: Create NIL, move it below, change layout, at this point, either cont or enter list

  [X]  [X]  [X] NIL
  A    B    NIL
  
  
  [X]  [X]  
  A    B    
  
  [X] NIL
  NIL  
  
  
  [X]  [X]  
  A    B    
  
  [Y] NIL
  NIL    
  
  Also where semantic move needs to follow layout so in y mode vs x mode, left
  and right are opposite

================================================================================

MODES

Caps lock - there is a light to indicate the mode, however it is not near the user's
focus. Most people touch type so they do not look down and pay attention to the
lights. If caps lock changed the cursor, it would be more indicative, similar to
insert mode


================================================================================
  
  X: 
    l/r = C/CDR 
    u/d = CAR
    ptr = CDR or PAIR
    
    * u/d only works on NIL and lists
  
  Y:
    l/r = CAR
    u/d = C/CDR
    ptr = ?
  
  If ptr on CAR replace entire thing (current)
  but technically replacing Car would create a sublist
  
  So if user types a bunch of cars, then goes back and presses a char...
  - here can be option to replace or append
  - most logical is append (also consistent with text)
    - create insert mode - replace sym also with _0
    - or do 3 parts _^0
  
  But if user enters Car, it will create a sublist
    
=============================

  [X] [X] [X] [X] [X] [X] NIL
  a   b   c   NIL NIL NIL

  Move middle:

    [X] [X] [X] [X]
    a   b   c   NIL

    [Y] NIL
    
    [X] NIL
    NIL
  
  Tab layout:
  
    [X] [X] [X] [X] [Y] NIL
    a   b   c   NIL [X] NIL
                    NIL
                    
    Must be space so:

    [X] [X] [X] [X] [Y] NIL
    a   b   c   NIL 
                    [X] NIL
                    NIL
  
=============================
  
  [X] [X] [X] [X] [X] [X] NIL
  a   b   c   NIL NIL NIL
  
  Below is same
  
  (a b c NIL NIL NIL)
    
  [X] [X] [X]
  a   b   c
  
  [Y] NIL

  [Y] NIL
  
  [Y] NIL

  NIL
  
  
  (a b c (NIL) (NIL) (NIL))
    
  [X] [X] [X]
  a   b   c
  
  [Y] [X] NIL
      NIL
  
  [Y] [X] NIL
      NIL

  [Y] [X] NIL
      NIL
  NIL
      

  (a b c (NIL (NIL (NIL))))
    
  [X] [X] [X]
  a   b   c
  
  [Y] [X] NIL
      NIL
  
      [Y] [X] NIL
          NIL

          [Y] [X] NIL
              NIL
          NIL
      NIL
  NIL
    
=================================

  (a b c (d e f) (h i j) (k l m))

  [X] [X] [X]
  a   b   c
  
  [Y] [X] [X] [X] NIL
      d   e   f
  
  [Y] [X] [X] [X] NIL
      h   i   j
  
  [Y] [X] [X] [X] NIL
      k   l   m
  NIL
  
  
  (a b c (d e f (h i j (k l m))))

  [X] [X] [X]
  a   b   c
  
  [Y] [X] [X] [X]
      d   e   f
  
      [Y] [X] [X] [X]
          h   i   j
    
          [Y] [X] [X] [X] NIL
              k   l   m
          NIL
      NIL
  NIL

================================================================================

Creating A Sublist:

[X] [X] [X] [X] NIL
a   b   c   NIL
            *0

To:

[X] [X] [X] [X] NIL
a   b   c   
            *0
            [X] NIL
            d
            
            
* Create additional line for ptr


With Y layout:
                *0
[X] [X] [X] [Y] [Y] d
a   b   c   NIL NIL
            
* Still a sublist

Then test nl, swap layout to Y

[X] [X] [X] 
a   b   c   

    *0
[Y] NIL
NIL


[X] [X] [X] 
a   b   c   

        *0
[Y] [X] NIL
NIL d


================================================================================

2 parts
- Calc min y for current line
- Update subsequent items/lines

Laying out an entire tree, nls can be tracked
So for piecewise building, must store nl info somewhere in the particle

Calc min y for all previous item's Cars
X is based on list origin

Again, need only do this from previous nl to current item

How to track nls?
* Walk backwards until NL encountered
* Put nl item in list of lines as list property
* Link lines to each other...? nl <-> nl
  -> Faster than checking every item every time 
     but not as much overhead as storing a list of line ptrs


[] [] [] []
a  b  c  d

[] [] [] []
e  f  g  h

[] [] [] []
i  j  k  l


a - e - i

Put cons in 'line

a.nl = (*main . b)
e.nl = (a . i)
i.nl = (e . NIL)

====================

Each list contains lines

sym = list

[a] [] [] []

[e] [] [] []

[i] [] [] []

sym.nl = (NIL . a)
a.nl = (sym . e)
e.nl = (a . i)
i.nl = (e . NIL)

*main -> lines

If lines don't link to each other than must search main list property
every time

If on a newline then .nl would have something

*line = [i]

[a] [] [] [] 

[e] [] [] [] 

           *
[i] [] [] []

To move to previous line, go to (car (get *line nl))

Store line bnds where? 
-> Create object for nl
-> Instead of cons pair, use object

================================================================================

[]   [] []
sym
     [] []
     
     [] []
     
+------------------------+
| []   [] [] [] [] [] [] |
| sym                    |
+------------------------+

 +------------+
 []   | [] [] |
 sym          |
 +------------+
     
      +-------+
      | [] [] |
      +-------+
     
      +-------+
      | [] [] | 
      +-------+


RECURSE SUPERLIST
            
[X]  [X]  [T]  [X]
           |
     [X]  [X]  [T]  [X]
                |
          [X]  [X]  [T]  [X]
                     |    +---+
          [X]  [X]  [X]  [X]  |
                              |
                             [X]


[X]  [X]  [T]  [X]
           |
          [X]  [X]  [T]  [X]
                |
               [X]  [X]  [T]  [X]
                     |
                    [X]  [X]  [X]  [X]


Poss maintain bnds in list also
Anytime line is updated, it is updated also if line bnds =

================================================================================

End

P A A A A ]

P A A A ]

Mid
      *
P A B C D]
      
      *
P A B X C D]

Adjust bnds to current item which only applies when ptr at end
Need to adjust bnds by width of new item

x bnds + width of new char with nil

[] [] [] NIL
|  |
[] []
|  |
[] []   *
|  |
[] []   [] NIL
|  |
[] []

==============

Every new line = new list?

R a b c d
  e f g h
  i j k l
  m n o p
   
= ((a b c d)
   (e f g h)
   (i j k l)
   (m n o p))


  [Y] [Y] [X] [X] [X] [X] NIL
       .   .   .   .   .
       
      [Y] [X] [X] [X] [X] NIL
       .   .   .   .   .
       
      [Y] [X] [X] [X] [X] NIL
       .   .   .   .   .
       
      [Y] [X] [X] [X] [X] NIL
       .   .   .   .   . 
  NIL

(
  (Lorem ipsum dolor sit amet, consectetur adipiscing elit.)
  (Praesent luctus lacus nec ultrices scelerisque.)
  (Nulla ultricies suscipit erat quis fermentum.)
  (Pellentesque leo mi, sollicitudin a rhoncus at, facilisis in diam.)
) 

  (let (a 1
        b 2)
    (+ a b))


  [Y] [X] NIL
      let
  
  [Y] [X] [X] [X] [X] NIL
      a   1   b   2
  
  [Y] [X] [X] [X] NIL
      +   a   b
  
  NIL
  
This would require custom function to layout 2nd arg

But then how to do multiline strings?

Alt+Enter will create new list

==============================
          
[X]  [X]  [X]  NIL
A    B    C
          *

[X]  [X]  [X]       [X]  ...
A    B    
               *
          [X]  NIL
          NIL


[X]  [X]  [X]       [X]  ...
A    B    
               *
          [X]  NIL
          C


Procedure to Create Sublist:
* Move to Car
* Create NIL
* Move ptr to Cdr NIL


1. Content
  1.1 Content
    1.1.1 Content
      1.1.1.1 Content
      1.1.1.2 Content
    1.1.2 Content
  1.2 Content
2. Content

(("1" "Content"
  ("1.1" "Content"
    ("1.1.1" "Content"
      ("1.1.1.1" "Content")
      ("1.1.1.2" "Content")))))


       [X]                                                                    [X]

       [X]  [X]      [X]                                                      [X]  [X]      [X]
       I    Content                                                           II   Content  ...
                     [X]  [X]      [X]                [X]                NIL
                     A    Content   
                                   [X]  [X]      NIL  [X]  [X]      NIL
                                   1    Content       2    Content
                                   
                                   
  [Y]  [X]  [X]
       I    Content

       [Y]  [X]  [X]
            A    Content

            [Y]  [X]  [X]       NIL
                 1    Content

            [Y]  [X]  [X]       NIL
                 2    Content

            NIL

       [Y]  [X]  [X]
            B    Content

            [Y]  [X]  [X]       NIL
                 1    Content

            [Y]  [X]  [X]       NIL
                 2    Content

            NIL

       NIL
  NIL
  
* Rule: Only lists can be on a newline
  * This guarantees that for the Car, the line p is always the list containing
  it, and the c is the Pair
* Store root in list (aka parent list)


After newline

On Pair/Cdr:
          *
[X]  [X]  [X]  NIL
A    B    C


[X]  [X]  [X]       [X]  ...
A    B    
               *
          [X]  NIL
          C

* Default to swap?

On Car:

          
[X]  [X]  [X]  NIL
A    B    C
          *


???

* Really meant as a way to move to a sublist
* Use this mode to replace the char


====================================    

  +-------+--------------------------------------------------------
  | CMD   |                           Pointer
  +-------+-------------------+--------------------+---------------
  |       | Pair/Atom         | Car/Atom           | NIL
  +-------+-------------------+--------------------+---------------
  | NL    | List w. Pair      | List w. Car        | Empty list
  +-------+-------------------+--------------------+---------------
  | ASCII | Ins-back, Mov-Cdr | Write-car, Mov-Car | Same as left
  +-------+-------------------+--------------------+---------------
  | NIL   | Same as above     | Same as above      | Ins...
  +-------+-------------------+--------------------+---------------

* Newline default
  * On car - empty list; same line, x layout
  * No car - list with car; newline , y layout

* For newline, which is more logical? OR swapable?
  * Char on Char, user expects Car to be replaced so current layout makes sense
* Char will move to sublist if pair has list

* For Newline + Car/List, newline should create a list containing that list
  * Not possible since Car becomes another Atom
  * Only Newline on Pair
* So Newline + Pair/List creates a list with the list
* For NIL, mov to Car, will create empty list, and for Pair, list with NIL

=============================

Newline + Pair/Atom

All these are same structure:

[X]  [X]  [X]  NIL
A    B    
          [X]  NIL
          C

* follows recursive pattern

----

y layout; no nl

[X]  [X]  [Y]  [X]  NIL
A    B    NIL  C

* poor legibility

------------

[X]  [X]
A    B    

[X]  NIL

[X]  NIL
C

* poor legibility

----

[X]  [X]
A    B    

[Y]  [X]  NIL
NIL  C   

* expectation is if no pair after, must be on newline

* Both are on a newline
* former is rel to origin of c, (Move Car, Enter char)
* latter is rel to list start (Enter char, Alt+Enter)
  -> Could also do newline on NIL

* if user wants empty list, create NIL

            X         Y

Same-line

Newline

===========

Nested list

  (a b (c))

  [X]  [X]
  A    B    
  
  *
  [Y]  [X]  NIL
  NIL  C
  
Call make-nl (note, ptr not on car)
  
  (a b ((c)))
  
  [X]  [X]
  A    B    

           *
  [Y]  [X] NIL
  NIL
  
       [Y]  [X]  NIL
       NIL  C

* move to inner or outer list? -> outer

=======================================
            *
  [X]  [X]  [X]  [X]  [X] NIL
  A    B    C    D    E


mov-nl:


  [X]  [X]  
  A    B    

  [Y]  [X]  NIL
       C
  
  [X]  [X] NIL
  D    E


solutions:
1. Don't allow it (does this make sense?)
2. Create as if on Car
3. Create two lines

===================

Nl on Cons/Cdr = Nested lists

  [X]  [X]  
  A    B    
  
  *
  [Y]  [X]  NIL
       C
  
  NIL
  
mov-nl
  
  [X]  [X]  
  A    B    
  
  * 
  [Y]  [Y]  [X]  NIL
            C
  
       NIL
  
  NIL  
  
  
Nl on Car = Serial lists

  [X]  [X]  [X]  NIL
  A    B    

            [X]  NIL
            C

  
mov-nl
  

  [X]  [X]  [X]  NIL
  A    B    

            [X]  NIL
  
            [X]  NIL
            C


Wait, this does not make sense:

*
[Y] CAR
CDR

*
[X] CDR
CAR

What is it pointing to?

You can point to the Pair or the Car but is it not the same thing?

So default should have pointer underneath...


[X]  [X]
CAR  CAR
*    *

Nm it is - ptr on top is pointing to CDR of Prv, even for the Y

===============================================


  [Y]   *    * 
       I    Content

       [Y]   *    * 
            A    Content

            [Y]   *    *        NIL
                 1    Content

                  *    *        NIL
                 1    Content

                  *    *        NIL
                 1    Content

            [Y]   *    *        NIL
                 2    Content
                 
                  *    *        NIL
                 2    Content

                  *    *        NIL
                 2    Content

             *    *    *    * 
            Foo  Bar  Baz  Boo

             *    *    *    * 
            Foo  Bar  Baz  Boo
            
             *    *    *    * 
            Foo  Bar  Baz  Boo  

       [Y]   *    * 
            B    Content

            [Y]   *    *        NIL
                 1    Content

            [Y]   *    *        NIL
                 2    Content

            NIL

       NIL
  NIL


Cancel update while it is running - use coroutine

Two coroutines:
* user-input
* tree update

loop can use co-routine when updating tree, it will yield nodes
it will check for input inbetween

=================================

New Line Class

[ ]  [ ]  [ ]        [ ]  [ ]        [ ]  
a    b               d               f
          
          [  ]  NIL       [  ]  NIL
          c               e
          
[ ]
g

4 lines in the above


Current Setup:

*main
p=NIL
c=[c,e]
n=g

c
p=*main
n=NIL

e
p=*main
n=NIL

g
p=*main
n=NIL


This would work with the current code
Would need to add checks to methods for line changes for sub/sup

When doing layout of main, when enter sublist, push cur to list
pop when leave list

Hierarchy of lines

================================================================================

Lines can either be doubly-linked and/or store list of symbols

To update children, traverse children or loop through list

================================================================================

Improving SDF at smaller sizes

http://www.java-gaming.org/topics/solved-signed-distance-field-fonts-look-crappy-at-small-pt-sizes/33612/view.html

https://www.essentialmath.com/blog/?p=151

https://discourse.libcinder.org/t/cinder-sdftext-initial-release-wip/171/14


===========================================================================

Very large strings - use a rope or skip-list or binary tree

===========

How to edit a a word/sublist in the middle of the string

If it is a single string, not possible to move the ptr - user must break it apart

Is there a way to do this automatically? ...such as when the user approaches the str

Maybe not the entire string but part of it at least...

After str is broken, user can mark parts of it
and do pattern matching

For space is there a way, to avoid double space? Use single dot, don't space bf or af

Create string mode for when user is over a string or list of strings?


When user breaks string, it must be rejoined 
before a search/replace
unless they explicitly programmatically conduct S/R

Demonstrate common scenarios/actions...

Edit a word like a misspelling
1. Split str into list of strs
  * Cache this for faster edits
    * Don't need to implcitly draw this
    * However, user can explicitly draw it with cmd or programmatically
  * Limit for very long strs
2. Pt to word
3. Ins/Del or Repl word
4. Glue strs

How to handle lines?
Cut/Copy/Paste? -> This moving items from buffer to ptr

When splitting lines, split by lines, then by space

===================================================

To optimize compute shader,

It is cheap to move all particles by an offset

To update particles, set the new origin and have the shader do all the calcs

That way, the only job of the CPU is to copy memory around

Instead of traversing the graph, we have a list of all the verts being used

Tell all workers to traverse all the verts to check

However only portions of the graph needed to be updated

Solution would be a 2-pass to figure out which verts need copying

Pass 1:
* Each worker scans their segment and sends results to ctrl
* Ctrl then divides the work and sends to workers
* Workers then upd/cpy their segment and send directly to render
* When done, commit to database

=================================================================

[ ]  [ ]
a    b

          *
[ ]  [ ]  NIL
     c

NIL


-> del


[ ]  [ ]
a    b

     *
[ ]  NIL


NIL


- NIL has X layout
- What about CDR NIL?
- What if user wants to make list?
- Ctrl-E creates NIL pair

https://www.phoronix.com/forums/forum/phoronix/latest-phoronix-articles/1171418-more-open-source-participants-are-backing-a-possible-fork-of-qt/page4

Good - Fast - Cheap

Choose 2 of 3

Commercial = Fast/Cheap
Hobbyist = Good/Fast

========================

DOUBLE-SHIFT

2 Commands
* Make Ref Pair the Car of New Pair = (cons Ref NIL)
  * Need not be on Car
  * Alt + Tab
* Make Newline
  * Alt + Enter


A:


    [ ]
    
    [Cc]  [C]  NIL
          a*
    NIL   

    ->
    
    [ ]
    
    [Cc]  [P]  [C]  NIL
               a*
          NIL
    NIL


B:
    
    
    [ ]  [Cc]  [C]  NIL
    a    b     c*
  
    ->
  
    [X]  [Cc]
    a    b

    [P]  [C]  NIL
         c*
    NIL

         

- A assumes Cc is Y layout
- B assumes Cc is X layout
- B creates line for P...so does A
  - B attaches to existing line
  
  
Is there a way to create a DSL for this like destructuring-bind

(Cc Ref)

transform to ->

(Cc (Ref))


how to label new part?

(Cc Ref)

transform to ->

(Cc (P . Ref))



==============

Tables

Row Major

((1,1  2,1  3,1  4,1)
 (1,2  2,2  3,2  4,2)
 (1,3  2,3  3,3  4,3)
 (1,4  2,4  3,4  4,4))

: (get l 1 4) -> first row, last col
: (get l 4 1) -> last row, first col


[Y] [Y] [X] [X] [X] [X]

    NIL

[Y] [Y] [X] [X] [X] [X]

    NIL

[Y] [Y] [X] [X] [X] [X]

    NIL

[Y] [Y] [X] [X] [X] [X]
   
    NIL   
   
NIL


Excel uses <alpha><num>

Use sym to reference it, cache value in sym



Pixels

- Need to remove spacing / NIL

Sublime Text Cmd search

Card metaphor

==============================================

DSL to relayout atoms like destructuring bind

[]
    *
[]  []  NIL
    x
NIL

(Ref)

->

(z Ref)

Prev: (setq z (gen-particle))


EXAMPLE:

(let (Ref (get *0 'b)
      P (gen-particle)
      I '(Ref)
      O '(P Ref))
  (restruct I O))

============================================

How to handle symbols?

When in list, don't expand
If not in list, expand

What happens when multiple particles drawn for same symbol?

Then what happens if that symbol's value is changed

Data changes properly but repr doesn't
It must be updated, which means it must be tracked/indexed, otherwise search
so any internal symbols drawn, ie gen-sym is called, it must index it

symbol : list of particles

=============

So should *start itself be in a list of global symbols
- no start itself is the root symbol
- well all the symbols with * are roots

=============

using the interface, how does the user make a symbol?

Programmatically:
internal: type string, eval intern
extern: eval new

UI:
intern: type string, eval intern
  - but how to set its value?
extern: type chars, make list, etc.


and how to delete?

========================================
(zap 'sym) -> sym
"Delete" the symbol sym. For internal symbols, that means to remove it from the
current namespace, effectively transforming it to a transient symbol. For
external symbols, it means to mark it as "deleted", so that upon a later commit
it will be removed from the database file. See also intern.
========================================
-> zap
: (setq L (list 'a 'b 'c))
-> (a b c)
: L
-> (a b c)
: (setq A 1 B 2 C 3)
-> 3
: L 
-> (a b c)
: (zap 'a)
-> "a"
: L
-> ("a" b c)


=============

(list "a" "b" "c")

(list a b c)

So for url's they become interal/external symbols, instead of trans symbols
Which means they point to something, er the name is symbolic for something

So mix of strings and links

*start = (list "This" "is" "a" 'link)

*start .     .   .  .
       This  is  a  link
       <B>   <B> <B> <C>

Example:

Given: 

(setq B 1)

Compare:

Data = Eval:

(list "A"  B  "C") = ("A" 1  "C")
(list "A" 'B  "C") = ("A" 'B  "C")
(list "A" 1  "C")  = ("A" 1 "C")

So don't draw value...
Ofc, user could eval all the symbols in a list and replace them with its values


https://www.mail-archive.com/picolisp@software-lab.de/msg07287.html

> (list (box) (box) (box))
> ...
> ($177760526373112 $177760526373114 $177760526373116)


> Where each memory location is two more than the previous. I am wondering

Yes. BTW, these are actually cell addresses, not bytes. The values have to be
multiplied by 16 to get the physical addresses. And the value is printed in
octal representation.

=============================================

https://news.ycombinator.com/item?id=18958046

For me it was efficiency of reading. It is proven that proportional, serif fonts read significantly faster (17%) [1] or [2] (6.1%). Also, in my opinion, scanning is much faster.

This makes sense: our eye uses the top and bottom of words to ‘key’ the word. Use proportional and you add information to this system.

[1] https://blog.codinghorror.com/comparing-font-legibility/

[2] https://journals.sagepub.com/doi/pdf/10.1177/001872088302500...

(edit: add references to research) 

If drawn after ptr, ptr is above
If drawn before ptr, ptr is under

So draw non-ptrs first
Then draw ptrs after

https://graphicdesign.stackexchange.com/questions/5650/do-all-monospace-sans-serif-fonts-look-the-same

http://s9w.github.io/font_compare/

systemE -> sinit -> 
sinit is a suckless init, initially based on Rich Felker's minimal init.

https://superuser.com/questions/320529/how-to-create-a-linux-system-that-runs-a-single-application/991733#991733

https://www.phoronix.com/forums/forum/phoronix/general-discussion/40672-richard-stallman-calls-llvm-a-terrible-setback/page16

https://news.ycombinator.com/item?id=19797152

Can anyone suggest interesting work that is kind of the opposite of this? Vast real estate, rich HIDs, dynamic autonomous presentation?

So focused on many/big screens, with an eye towards future high-res AR/VR 3D, rather than a single "space is precious" small screen. Rich human interface devices, like multitouch and 3D hand pose and stylus and head position and gaze, rather than a single mouse. Display as a dynamic ecosystem of presentations, under the influence of multiple agents, rather than detailed manual control. UI as collaborative improv dance, rather than as micromanagement.

Punchcards and console toggles; teletype printer; VT100 terminal; small bitmapped monitor and mouse; larger monitor; largerer monitor; largererer; multiple monitors; with multitouch and stylus tablet; future high-res AR/VR... as tech so very slowly becomes less crippling, the UIs do too...

Hmm, though for current VR, with its 1980's VGA-like non-blurry pixels are more precious than they've been for decades, fine-grained control and space sharing might be quite nice? 

https://en.wikipedia.org/wiki/AoS_and_SoA

https://github.com/pel-daniel/mind-bicycles

=============================================


https://news.ycombinator.com/item?id=19746122

Summary:

- We don't need separate processes if the language we use is inherently safe (e.g., modern Common Lisp).

- Without process isolation, it is possible to share large, complicated and possibly mutable data structures (graphs, arrays, user-defined objects) system-wide.

- Once it is possible to cheaply share and communicate arbitrary data structures, it is pointless to maintain designated 'file system'.

- Not having a file system raises the question of what data should be persistent and what shouldn't. But on a modern computer, it is feasible to just treat all data as persistent (maybe excluding the youngest GC generation).

The best news is that the author is actually working hard to implement this operating system. The first part - the Lisp implementation - is already in a pretty good shape and could be finished within the next two years: https://github.com/robert-strandh/SICL 


=================================

PIM: Search, Hierarchy/Tree, Tag

Trees allow indexing on data
Tags allow indexing on trees
Search allows indexing on tags

=================================

Load turns strings into data
Then evals main

=================================

I could create libraries for PicoLisp but it wouldn't be standardized

Without a lead application, there can be no standard libraries; a project has to take charge

But why hasn't Allegro CL or LispWorks created standard libraries?
They have but it's commercial only
So had they released it to the public, it would help?
Yes, but they wouldn't since that's how they make their money

===============

Possible to pack cells or "unroll"

: (list (adr (cons)) (adr (cons)) (adr (cons)))
-> (8758778893956 8758778893958 8758778893960)

Then use place to modify after

==============================

the skip list, a similar variation on the linked list, 
offers fast lookup and hurts the advantages of linked lists (quick insert/deletion) 
less than an unrolled linked list

==============

Compile pilasm
https://freenode.irclog.whitequark.org/picolisp/2018-08-10#22800426

    #!bin/picolisp lib.l
    # 08may16abu

    (load "lib/misc.l")

    (setq
      *Architecture "arm64"
      *System ".linux"
      *TargetOS "Linux" )

    (load "src64/lib/asm.l"
      (pack "src64/lib/fmt.s.l")
      (pack "src64/arch/" *Architecture ".l") T )

    (build NIL ""
      (load
          (pack "src64/sys/" *Architecture *System ".defs.l")
          "src64/defs.l"
          "asm.l" ) )

    (call "rm" "arm64.symtab")

    (bye)

=========
    
Multilisp
PCALL FUTURE

MultiLisp achieves parallelism with the PCALL macro, where

(PCALL Fun A B C ...)

is equivalent to

(Fun A B C ...)

except that the arguments A, B, C, etc. are explicitly allowed to be evaluated in parallel; this circumvents the usual order of evaluation, which is sequential and left to right. It also makes use of a parallel programming construct called futures, which resembles forking, combined with lazy evaluation. Using this construct, an expression such as

(cons (FUTURE A) (FUTURE B))

can be written, which will overlap the evaluation of the expressions A and B, not only with each other, but with computations that use the result of the cons call, until an operation is performed that needs correct information about the value of A or B. 
    

=============    
    
buffered gc:
https://www.jstage.jst.go.jp/article/ipsjjip/27/0/27_479/_pdf


https://github.com/status-im/nimbus/wiki/Interpreter-optimization-resources


==============

RGBA = list of ints

RGBA -> +Pixel

(+Pixel ...) -> +Img

(save +Img Path) 

where +Img is an image so literally depicted as:

'save  []  "some/file/path/name.ext"

which is semantically equivalent to:

(save (+Pixel ...) "some/file/path/name.ext") = (save ((R G B A) (R G B A) ...)  "some/file/path/name.ext")

Think as text IS a glyph which IS an image, so everything is an image
Thus, "text" and "images" can be mixed together seamlessly

So this composition is like a visual macro?

Macros increase expressiveness by increasing abstractness
The user sees an image rather than mentally parsing text and thinking what it represents
It visually reduces the amount of information or compresses it, (in terms of information theory/entropy)
so the user needs less information to process/recognize

Macros do this at a semantic level, however, we need a way to do this at a syntax level
Syntax meaning symbols representing the data/code
Generally programmers think in terms of text/tokens
but its ultimately about symbols (like APL?)

So what we want to do is to be able to perform the equivalent of macros on symbols
I.e. we take it another step further and compress at the visual/glyphic/symbolic level

Expressiveness usually means more bang for your buck
i.e. less code necessary = less LOC = less bugs (naively speaking)

Glyph Level: [] [] [] [] ->  [][][][]
             |  |  |  |      +---+--+
             |  |  |  |          |
             |  |  |  |      +---+---+
Code Level: (() () () ()) -> (. . . .)

More assumptions must be made by the underlying system
to figure out intent of a sufficiently succint statement or expression

https://wiki.c2.com/?CritiqueOfIntentionalProgramming

=================================

Abstractions are easy to understand horizontally due to the DSL

However, abstraction needs consistency all the way through vertically to maintain consistency horizontally

Abstractions when debugged, need to be understood throughout

Using a series of macros versus a series of functions in an API is mentally different
since the functions are only modifying their data and not both the syntax and the data

What typically happens is when the base changes, aka environment changes,
the abstractions break and they leak

What Lisp has to offset the complexity of the tower of babel
is it unifies code and data whereas mixing DSLs of different languages
with different syntax creates larger complexity

3. Any large software project with poor management and communication. 4. Any software project employing multiple implementation languages [4]. 5. A software project that solves problems via the Unix philosophy of linking many small, existing, domain specific tools together, rather than producing a complete, monolithic, monumental pile of code that will become historically notorious for its failure.

============================================

To incorporate, Unix users, need file interface or to improve upon it

Less dependencies mean the base language has the batteries included
but those batteries can only exist through concensus

SCENARIO 1:

  (c)

  ->

  ("^M"
   ((c)))
  
  * Indicates changes:
    * Move c to newline
    * Put c in own list

SCENARIO 2:

  (a "^M"
   (Ref))
   
   ->
   
  (a "^M"
   ((Ref)))
   

IMPL:

* Find ref in Input
* Gen symbols rel to ref
* Process Output

(let (R <Ref>)
  ...)
  
(for Sym Output
  (let Type (type Sym)
    (cond ((and (= Type '(+Str))
                (= Sym "^M"))
           # Create line for next item
           (new '(+Line) (get Sym 'b)))
          ((= Type '(+Pair))
           (a> Prev Sym))
          ((= Type '(+Sym))
           (b> Prev Sym)))))
    
...no

============================================

Image is list of pixels

Audio is list of samples
Total samples = samples * hz

A 3 min song @ 44100 hz = 7,938,000 samples
so better to divide in seconds instead of producing 8 million cons = ~246 MB

pixel = sample

bits
numbers/ptrs
cells
symbols
dsl...

research vim modes

============================================

modes can exist as long as they can accomodate Lisp CUA
Data has to break down to lisp data which is enforced by the language

support both emacs and vim users
- emacs supports vim but not competely

when user is editing strings
they should be able to use the spaces between as single line buffer
- that is the status bar

CDR MODE:
PTR
XXXX
ZZZZ

CAR MODE:
ZZZZ
XXXX
PTR

if user outputs instead of replaces
the they must manually move it

the expression problem

======================

what if manipulate data then get data:particle?

======================

hash fns
https://gist.github.com/badboy/6267743

https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key


Positions never overlap so can use positions as keys
then do range search


==============================

if we use a class
how to draw obj with properties?

                                                                                      Symbol
                                                                                        |
                                                                                        V                              
    +----------+---------+     +-----+-----+     +-----+-----+     +-----+--+--+     +-----+-----+
    |'hgfedcba'|'onmlkji'| <---+  |  |     | <---+ KEY |     | <---+  |  |  |  | <---+  |  | VAL + 
    +----------+---------+     +--+--+-----+     +-----+-----+     +--+--+-----+     +--+--+-----+
                                  |                                   | 
                                  V                                   V 
                                  +-----+-----+                       +-----+-----+ 
                                  | VAL | KEY |                       | VAL | KEY | 
                                  +-----+-----+                       +-----+-----+                         
    
    (n (k1 (v1)) (k2) (k1 (v1)) s)

    
    
    condense, or hide cells:
    

    +----------+---------+            +-----+-----+            +-----+-----+
    |'hgfedcba'|'onmlkji'| <--- C <---+ KEY |     | <--- C <---+  |  | VAL + 
    +----------+---------+            +-----+-----+            +--+--+-----+

    use dot with special color - red?
    -> uses particle principles - symbol to represent a cell
    
============================================

 *    *    *    *
[ ]  [ ]  [ ]  [ ]
 a    b    c    d
 
 
Cmd List 
* ...

Ptr List (Modes)
* ptr

Sel List
* [ptr will push selection to car of list]

Property List
[property list of sel objects]

Main List    
* main ...
    

What if user moves to sel list
- Can't do anything if already selected
    
    
=======================================
    
    
https://www.reddit.com/r/vexillology/comments/7dxjme/flag_of_the_grid_tron_legacy/    
    
    
========================================

Problem 1

[] [] []
.  .  .

<- how to insert here

[Y] [] NIL
     .

NIL

Solutions:
1. Ins before Y pair
2. Go to first line, end atom, type chars, then split line
    

============================================
============================================

https://news.ycombinator.com/item?id=20191406

https://no-kill-switch.ghost.io/the-rise-of-personal-knowledge-management-tools/

https://news.ycombinator.com/item?id=9831429

https://news.ycombinator.com/item?id=7878679

https://hn.algolia.com/?dateRange=all&page=0&prefix=true&query=lisp%20failed&sort=byDate&type=all

https://news.ycombinator.com/item?id=22580884

# UI and software profession
https://news.ycombinator.com/item?id=22901541

https://no-kill-switch.ghost.io/the-rise-of-personal-knowledge-management-tools/
